

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  
<!-- Mirrored from llvm.org/docs/WritingAnLLVMBackend.html by HTTrack Website Copier/3.x [XR&CO'2013], Sat, 26 Apr 2014 21:32:25 GMT -->
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Writing an LLVM Backend &mdash; LLVM 3.4 documentation</title>
    
    <link rel="stylesheet" href="_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="LLVM 3.4 documentation" href="index-2.html" />
    <link rel="next" title="How To Use Instruction Mappings" href="HowToUseInstrMappings.html" />
    <link rel="prev" title="Auto-Vectorization in LLVM" href="Vectorizers.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head>
  <body>
<div class="logo">
  <a href="index-2.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="HowToUseInstrMappings.html" title="How To Use Instruction Mappings"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Vectorizers.html" title="Auto-Vectorization in LLVM"
             accesskey="P">previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index-2.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>


    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="writing-an-llvm-backend">
<h1>Writing an LLVM Backend<a class="headerlink" href="#writing-an-llvm-backend" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id3">Introduction</a><ul>
<li><a class="reference internal" href="#audience" id="id4">Audience</a></li>
<li><a class="reference internal" href="#prerequisite-reading" id="id5">Prerequisite Reading</a></li>
<li><a class="reference internal" href="#basic-steps" id="id6">Basic Steps</a></li>
<li><a class="reference internal" href="#preliminaries" id="id7">Preliminaries</a></li>
</ul>
</li>
<li><a class="reference internal" href="#target-machine" id="id8">Target Machine</a></li>
<li><a class="reference internal" href="#target-registration" id="id9">Target Registration</a></li>
<li><a class="reference internal" href="#register-set-and-register-classes" id="id10">Register Set and Register Classes</a><ul>
<li><a class="reference internal" href="#defining-a-register" id="id11">Defining a Register</a></li>
<li><a class="reference internal" href="#defining-a-register-class" id="id12">Defining a Register Class</a></li>
<li><a class="reference internal" href="#implement-a-subclass-of-targetregisterinfo" id="id13">Implement a subclass of <tt class="docutils literal"><span class="pre">TargetRegisterInfo</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#instruction-set" id="id14">Instruction Set</a><ul>
<li><a class="reference internal" href="#instruction-operand-mapping" id="id15">Instruction Operand Mapping</a><ul>
<li><a class="reference internal" href="#instruction-operand-name-mapping" id="id16">Instruction Operand Name Mapping</a></li>
<li><a class="reference internal" href="#instruction-operand-types" id="id17">Instruction Operand Types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#instruction-scheduling" id="id18">Instruction Scheduling</a></li>
<li><a class="reference internal" href="#instruction-relation-mapping" id="id19">Instruction Relation Mapping</a></li>
<li><a class="reference internal" href="#implement-a-subclass-of-targetinstrinfo" id="id20">Implement a subclass of <tt class="docutils literal"><span class="pre">TargetInstrInfo</span></tt></a></li>
<li><a class="reference internal" href="#branch-folding-and-if-conversion" id="id21">Branch Folding and If Conversion</a></li>
</ul>
</li>
<li><a class="reference internal" href="#instruction-selector" id="id22">Instruction Selector</a><ul>
<li><a class="reference internal" href="#the-selectiondag-legalize-phase" id="id23">The SelectionDAG Legalize Phase</a><ul>
<li><a class="reference internal" href="#promote" id="id24">Promote</a></li>
<li><a class="reference internal" href="#expand" id="id25">Expand</a></li>
<li><a class="reference internal" href="#custom" id="id26">Custom</a></li>
<li><a class="reference internal" href="#legal" id="id27">Legal</a></li>
</ul>
</li>
<li><a class="reference internal" href="#calling-conventions" id="id28">Calling Conventions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#assembly-printer" id="id29">Assembly Printer</a></li>
<li><a class="reference internal" href="#subtarget-support" id="id30">Subtarget Support</a></li>
<li><a class="reference internal" href="#jit-support" id="id31">JIT Support</a><ul>
<li><a class="reference internal" href="#machine-code-emitter" id="id32">Machine Code Emitter</a></li>
<li><a class="reference internal" href="#target-jit-info" id="id33">Target JIT Info</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id3">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This document describes techniques for writing compiler backends that convert
the LLVM Intermediate Representation (IR) to code for a specified machine or
other languages.  Code intended for a specific machine can take the form of
either assembly code or binary code (usable for a JIT compiler).</p>
<p>The backend of LLVM features a target-independent code generator that may
create output for several types of target CPUs &#8212; including X86, PowerPC,
ARM, and SPARC.  The backend may also be used to generate code targeted at SPUs
of the Cell processor or GPUs to support the execution of compute kernels.</p>
<p>The document focuses on existing examples found in subdirectories of
<tt class="docutils literal"><span class="pre">llvm/lib/Target</span></tt> in a downloaded LLVM release.  In particular, this document
focuses on the example of creating a static compiler (one that emits text
assembly) for a SPARC target, because SPARC has fairly standard
characteristics, such as a RISC instruction set and straightforward calling
conventions.</p>
<div class="section" id="audience">
<h3><a class="toc-backref" href="#id4">Audience</a><a class="headerlink" href="#audience" title="Permalink to this headline">¶</a></h3>
<p>The audience for this document is anyone who needs to write an LLVM backend to
generate code for a specific hardware or software target.</p>
</div>
<div class="section" id="prerequisite-reading">
<h3><a class="toc-backref" href="#id5">Prerequisite Reading</a><a class="headerlink" href="#prerequisite-reading" title="Permalink to this headline">¶</a></h3>
<p>These essential documents must be read before reading this document:</p>
<ul class="simple">
<li><a class="reference external" href="LangRef.html">LLVM Language Reference Manual</a> &#8212; a reference manual for
the LLVM assembly language.</li>
<li><a class="reference internal" href="CodeGenerator.html"><em>The LLVM Target-Independent Code Generator</em></a> &#8212; a guide to the components (classes and code
generation algorithms) for translating the LLVM internal representation into
machine code for a specified target.  Pay particular attention to the
descriptions of code generation stages: Instruction Selection, Scheduling and
Formation, SSA-based Optimization, Register Allocation, Prolog/Epilog Code
Insertion, Late Machine Code Optimizations, and Code Emission.</li>
<li><a class="reference internal" href="TableGen/index.html"><em>TableGen</em></a> &#8212; a document that describes the TableGen
(<tt class="docutils literal"><span class="pre">tblgen</span></tt>) application that manages domain-specific information to support
LLVM code generation.  TableGen processes input from a target description
file (<tt class="docutils literal"><span class="pre">.td</span></tt> suffix) and generates C++ code that can be used for code
generation.</li>
<li><a class="reference internal" href="WritingAnLLVMPass.html"><em>Writing an LLVM Pass</em></a> &#8212; The assembly printer is a <tt class="docutils literal"><span class="pre">FunctionPass</span></tt>, as
are several <tt class="docutils literal"><span class="pre">SelectionDAG</span></tt> processing steps.</li>
</ul>
<p>To follow the SPARC examples in this document, have a copy of <a class="reference external" href="http://www.sparc.org/standards/V8.pdf">The SPARC
Architecture Manual, Version 8</a> for
reference.  For details about the ARM instruction set, refer to the <a class="reference external" href="http://infocenter.arm.com/">ARM
Architecture Reference Manual</a>.  For more about
the GNU Assembler format (<tt class="docutils literal"><span class="pre">GAS</span></tt>), see <a class="reference external" href="http://sourceware.org/binutils/docs/as/index.html">Using As</a>, especially for the
assembly printer.  &#8220;Using As&#8221; contains a list of target machine dependent
features.</p>
</div>
<div class="section" id="basic-steps">
<h3><a class="toc-backref" href="#id6">Basic Steps</a><a class="headerlink" href="#basic-steps" title="Permalink to this headline">¶</a></h3>
<p>To write a compiler backend for LLVM that converts the LLVM IR to code for a
specified target (machine or other language), follow these steps:</p>
<ul class="simple">
<li>Create a subclass of the <tt class="docutils literal"><span class="pre">TargetMachine</span></tt> class that describes
characteristics of your target machine.  Copy existing examples of specific
<tt class="docutils literal"><span class="pre">TargetMachine</span></tt> class and header files; for example, start with
<tt class="docutils literal"><span class="pre">SparcTargetMachine.cpp</span></tt> and <tt class="docutils literal"><span class="pre">SparcTargetMachine.h</span></tt>, but change the file
names for your target.  Similarly, change code that references &#8220;<tt class="docutils literal"><span class="pre">Sparc</span></tt>&#8221; to
reference your target.</li>
<li>Describe the register set of the target.  Use TableGen to generate code for
register definition, register aliases, and register classes from a
target-specific <tt class="docutils literal"><span class="pre">RegisterInfo.td</span></tt> input file.  You should also write
additional code for a subclass of the <tt class="docutils literal"><span class="pre">TargetRegisterInfo</span></tt> class that
represents the class register file data used for register allocation and also
describes the interactions between registers.</li>
<li>Describe the instruction set of the target.  Use TableGen to generate code
for target-specific instructions from target-specific versions of
<tt class="docutils literal"><span class="pre">TargetInstrFormats.td</span></tt> and <tt class="docutils literal"><span class="pre">TargetInstrInfo.td</span></tt>.  You should write
additional code for a subclass of the <tt class="docutils literal"><span class="pre">TargetInstrInfo</span></tt> class to represent
machine instructions supported by the target machine.</li>
<li>Describe the selection and conversion of the LLVM IR from a Directed Acyclic
Graph (DAG) representation of instructions to native target-specific
instructions.  Use TableGen to generate code that matches patterns and
selects instructions based on additional information in a target-specific
version of <tt class="docutils literal"><span class="pre">TargetInstrInfo.td</span></tt>.  Write code for <tt class="docutils literal"><span class="pre">XXXISelDAGToDAG.cpp</span></tt>,
where <tt class="docutils literal"><span class="pre">XXX</span></tt> identifies the specific target, to perform pattern matching and
DAG-to-DAG instruction selection.  Also write code in <tt class="docutils literal"><span class="pre">XXXISelLowering.cpp</span></tt>
to replace or remove operations and data types that are not supported
natively in a SelectionDAG.</li>
<li>Write code for an assembly printer that converts LLVM IR to a GAS format for
your target machine.  You should add assembly strings to the instructions
defined in your target-specific version of <tt class="docutils literal"><span class="pre">TargetInstrInfo.td</span></tt>.  You
should also write code for a subclass of <tt class="docutils literal"><span class="pre">AsmPrinter</span></tt> that performs the
LLVM-to-assembly conversion and a trivial subclass of <tt class="docutils literal"><span class="pre">TargetAsmInfo</span></tt>.</li>
<li>Optionally, add support for subtargets (i.e., variants with different
capabilities).  You should also write code for a subclass of the
<tt class="docutils literal"><span class="pre">TargetSubtarget</span></tt> class, which allows you to use the <tt class="docutils literal"><span class="pre">-mcpu=</span></tt> and
<tt class="docutils literal"><span class="pre">-mattr=</span></tt> command-line options.</li>
<li>Optionally, add JIT support and create a machine code emitter (subclass of
<tt class="docutils literal"><span class="pre">TargetJITInfo</span></tt>) that is used to emit binary code directly into memory.</li>
</ul>
<p>In the <tt class="docutils literal"><span class="pre">.cpp</span></tt> and <tt class="docutils literal"><span class="pre">.h</span></tt>. files, initially stub up these methods and then
implement them later.  Initially, you may not know which private members that
the class will need and which components will need to be subclassed.</p>
</div>
<div class="section" id="preliminaries">
<h3><a class="toc-backref" href="#id7">Preliminaries</a><a class="headerlink" href="#preliminaries" title="Permalink to this headline">¶</a></h3>
<p>To actually create your compiler backend, you need to create and modify a few
files.  The absolute minimum is discussed here.  But to actually use the LLVM
target-independent code generator, you must perform the steps described in the
<a class="reference internal" href="CodeGenerator.html"><em>LLVM Target-Independent Code Generator</em></a> document.</p>
<p>First, you should create a subdirectory under <tt class="docutils literal"><span class="pre">lib/Target</span></tt> to hold all the
files related to your target.  If your target is called &#8220;Dummy&#8221;, create the
directory <tt class="docutils literal"><span class="pre">lib/Target/Dummy</span></tt>.</p>
<p>In this new directory, create a <tt class="docutils literal"><span class="pre">Makefile</span></tt>.  It is easiest to copy a
<tt class="docutils literal"><span class="pre">Makefile</span></tt> of another target and modify it.  It should at least contain the
<tt class="docutils literal"><span class="pre">LEVEL</span></tt>, <tt class="docutils literal"><span class="pre">LIBRARYNAME</span></tt> and <tt class="docutils literal"><span class="pre">TARGET</span></tt> variables, and then include
<tt class="docutils literal"><span class="pre">$(LEVEL)/Makefile.common</span></tt>.  The library can be named <tt class="docutils literal"><span class="pre">LLVMDummy</span></tt> (for
example, see the MIPS target).  Alternatively, you can split the library into
<tt class="docutils literal"><span class="pre">LLVMDummyCodeGen</span></tt> and <tt class="docutils literal"><span class="pre">LLVMDummyAsmPrinter</span></tt>, the latter of which should be
implemented in a subdirectory below <tt class="docutils literal"><span class="pre">lib/Target/Dummy</span></tt> (for example, see the
PowerPC target).</p>
<p>Note that these two naming schemes are hardcoded into <tt class="docutils literal"><span class="pre">llvm-config</span></tt>.  Using
any other naming scheme will confuse <tt class="docutils literal"><span class="pre">llvm-config</span></tt> and produce a lot of
(seemingly unrelated) linker errors when linking <tt class="docutils literal"><span class="pre">llc</span></tt>.</p>
<p>To make your target actually do something, you need to implement a subclass of
<tt class="docutils literal"><span class="pre">TargetMachine</span></tt>.  This implementation should typically be in the file
<tt class="docutils literal"><span class="pre">lib/Target/DummyTargetMachine.cpp</span></tt>, but any file in the <tt class="docutils literal"><span class="pre">lib/Target</span></tt>
directory will be built and should work.  To use LLVM&#8217;s target independent code
generator, you should do what all current machine backends do: create a
subclass of <tt class="docutils literal"><span class="pre">LLVMTargetMachine</span></tt>.  (To create a target from scratch, create a
subclass of <tt class="docutils literal"><span class="pre">TargetMachine</span></tt>.)</p>
<p>To get LLVM to actually build and link your target, you need to add it to the
<tt class="docutils literal"><span class="pre">TARGETS_TO_BUILD</span></tt> variable.  To do this, you modify the configure script to
know about your target when parsing the <tt class="docutils literal"><span class="pre">--enable-targets</span></tt> option.  Search
the configure script for <tt class="docutils literal"><span class="pre">TARGETS_TO_BUILD</span></tt>, add your target to the lists
there (some creativity required), and then reconfigure.  Alternatively, you can
change <tt class="docutils literal"><span class="pre">autotools/configure.ac</span></tt> and regenerate configure by running
<tt class="docutils literal"><span class="pre">./autoconf/AutoRegen.sh</span></tt>.</p>
</div>
</div>
<div class="section" id="target-machine">
<h2><a class="toc-backref" href="#id8">Target Machine</a><a class="headerlink" href="#target-machine" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">LLVMTargetMachine</span></tt> is designed as a base class for targets implemented with
the LLVM target-independent code generator.  The <tt class="docutils literal"><span class="pre">LLVMTargetMachine</span></tt> class
should be specialized by a concrete target class that implements the various
virtual methods.  <tt class="docutils literal"><span class="pre">LLVMTargetMachine</span></tt> is defined as a subclass of
<tt class="docutils literal"><span class="pre">TargetMachine</span></tt> in <tt class="docutils literal"><span class="pre">include/llvm/Target/TargetMachine.h</span></tt>.  The
<tt class="docutils literal"><span class="pre">TargetMachine</span></tt> class implementation (<tt class="docutils literal"><span class="pre">TargetMachine.cpp</span></tt>) also processes
numerous command-line options.</p>
<p>To create a concrete target-specific subclass of <tt class="docutils literal"><span class="pre">LLVMTargetMachine</span></tt>, start
by copying an existing <tt class="docutils literal"><span class="pre">TargetMachine</span></tt> class and header.  You should name the
files that you create to reflect your specific target.  For instance, for the
SPARC target, name the files <tt class="docutils literal"><span class="pre">SparcTargetMachine.h</span></tt> and
<tt class="docutils literal"><span class="pre">SparcTargetMachine.cpp</span></tt>.</p>
<p>For a target machine <tt class="docutils literal"><span class="pre">XXX</span></tt>, the implementation of <tt class="docutils literal"><span class="pre">XXXTargetMachine</span></tt> must
have access methods to obtain objects that represent target components.  These
methods are named <tt class="docutils literal"><span class="pre">get*Info</span></tt>, and are intended to obtain the instruction set
(<tt class="docutils literal"><span class="pre">getInstrInfo</span></tt>), register set (<tt class="docutils literal"><span class="pre">getRegisterInfo</span></tt>), stack frame layout
(<tt class="docutils literal"><span class="pre">getFrameInfo</span></tt>), and similar information.  <tt class="docutils literal"><span class="pre">XXXTargetMachine</span></tt> must also
implement the <tt class="docutils literal"><span class="pre">getDataLayout</span></tt> method to access an object with target-specific
data characteristics, such as data type size and alignment requirements.</p>
<p>For instance, for the SPARC target, the header file <tt class="docutils literal"><span class="pre">SparcTargetMachine.h</span></tt>
declares prototypes for several <tt class="docutils literal"><span class="pre">get*Info</span></tt> and <tt class="docutils literal"><span class="pre">getDataLayout</span></tt> methods that
simply return a class member.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">Module</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">SparcTargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">LLVMTargetMachine</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">DataLayout</span> <span class="n">DataLayout</span><span class="p">;</span>       <span class="c1">// Calculates type size &amp; alignment</span>
  <span class="n">SparcSubtarget</span> <span class="n">Subtarget</span><span class="p">;</span>
  <span class="n">SparcInstrInfo</span> <span class="n">InstrInfo</span><span class="p">;</span>
  <span class="n">TargetFrameInfo</span> <span class="n">FrameInfo</span><span class="p">;</span>

<span class="nl">protected:</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetAsmInfo</span> <span class="o">*</span><span class="n">createTargetAsmInfo</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="nl">public:</span>
  <span class="n">SparcTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Module</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">FS</span><span class="p">);</span>

  <span class="k">virtual</span> <span class="k">const</span> <span class="n">SparcInstrInfo</span> <span class="o">*</span><span class="n">getInstrInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="o">&amp;</span><span class="n">InstrInfo</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetFrameInfo</span> <span class="o">*</span><span class="n">getFrameInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span><span class="k">return</span> <span class="o">&amp;</span><span class="n">FrameInfo</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetSubtarget</span> <span class="o">*</span><span class="n">getSubtargetImpl</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span><span class="k">return</span> <span class="o">&amp;</span><span class="n">Subtarget</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">getRegisterInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">InstrInfo</span><span class="p">.</span><span class="n">getRegisterInfo</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">DataLayout</span> <span class="o">*</span><span class="n">getDataLayout</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">DataLayout</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">static</span> <span class="kt">unsigned</span> <span class="n">getModuleMatchQuality</span><span class="p">(</span><span class="k">const</span> <span class="n">Module</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">);</span>

  <span class="c1">// Pass Pipeline Configuration</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">addInstSelector</span><span class="p">(</span><span class="n">PassManagerBase</span> <span class="o">&amp;</span><span class="n">PM</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">Fast</span><span class="p">);</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">addPreEmitPass</span><span class="p">(</span><span class="n">PassManagerBase</span> <span class="o">&amp;</span><span class="n">PM</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">Fast</span><span class="p">);</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace llvm</span>
</pre></div>
</div>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">getInstrInfo()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">getRegisterInfo()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">getFrameInfo()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">getDataLayout()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">getSubtargetImpl()</span></tt></li>
</ul>
<p>For some targets, you also need to support the following methods:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">getTargetLowering()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">getJITInfo()</span></tt></li>
</ul>
<p>Some architectures, such as GPUs, do not support jumping to an arbitrary
program location and implement branching using masked execution and loop using
special instructions around the loop body. In order to avoid CFG modifications
that introduce irreducible control flow not handled by such hardware, a target
must call <cite>setRequiresStructuredCFG(true)</cite> when being initialized.</p>
<p>In addition, the <tt class="docutils literal"><span class="pre">XXXTargetMachine</span></tt> constructor should specify a
<tt class="docutils literal"><span class="pre">TargetDescription</span></tt> string that determines the data layout for the target
machine, including characteristics such as pointer size, alignment, and
endianness.  For example, the constructor for <tt class="docutils literal"><span class="pre">SparcTargetMachine</span></tt> contains
the following:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SparcTargetMachine</span><span class="o">::</span><span class="n">SparcTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Module</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">FS</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">DataLayout</span><span class="p">(</span><span class="s">&quot;E-p:32:32-f128:128:128&quot;</span><span class="p">),</span>
    <span class="n">Subtarget</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">FS</span><span class="p">),</span> <span class="n">InstrInfo</span><span class="p">(</span><span class="n">Subtarget</span><span class="p">),</span>
    <span class="n">FrameInfo</span><span class="p">(</span><span class="n">TargetFrameInfo</span><span class="o">::</span><span class="n">StackGrowsDown</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Hyphens separate portions of the <tt class="docutils literal"><span class="pre">TargetDescription</span></tt> string.</p>
<ul class="simple">
<li>An upper-case &#8220;<tt class="docutils literal"><span class="pre">E</span></tt>&#8221; in the string indicates a big-endian target data model.
A lower-case &#8220;<tt class="docutils literal"><span class="pre">e</span></tt>&#8221; indicates little-endian.</li>
<li>&#8220;<tt class="docutils literal"><span class="pre">p:</span></tt>&#8221; is followed by pointer information: size, ABI alignment, and
preferred alignment.  If only two figures follow &#8220;<tt class="docutils literal"><span class="pre">p:</span></tt>&#8221;, then the first
value is pointer size, and the second value is both ABI and preferred
alignment.</li>
<li>Then a letter for numeric type alignment: &#8220;<tt class="docutils literal"><span class="pre">i</span></tt>&#8221;, &#8220;<tt class="docutils literal"><span class="pre">f</span></tt>&#8221;, &#8220;<tt class="docutils literal"><span class="pre">v</span></tt>&#8221;, or
&#8220;<tt class="docutils literal"><span class="pre">a</span></tt>&#8221; (corresponding to integer, floating point, vector, or aggregate).
&#8220;<tt class="docutils literal"><span class="pre">i</span></tt>&#8221;, &#8220;<tt class="docutils literal"><span class="pre">v</span></tt>&#8221;, or &#8220;<tt class="docutils literal"><span class="pre">a</span></tt>&#8221; are followed by ABI alignment and preferred
alignment. &#8220;<tt class="docutils literal"><span class="pre">f</span></tt>&#8221; is followed by three values: the first indicates the size
of a long double, then ABI alignment, and then ABI preferred alignment.</li>
</ul>
</div>
<div class="section" id="target-registration">
<h2><a class="toc-backref" href="#id9">Target Registration</a><a class="headerlink" href="#target-registration" title="Permalink to this headline">¶</a></h2>
<p>You must also register your target with the <tt class="docutils literal"><span class="pre">TargetRegistry</span></tt>, which is what
other LLVM tools use to be able to lookup and use your target at runtime.  The
<tt class="docutils literal"><span class="pre">TargetRegistry</span></tt> can be used directly, but for most targets there are helper
templates which should take care of the work for you.</p>
<p>All targets should declare a global <tt class="docutils literal"><span class="pre">Target</span></tt> object which is used to
represent the target during registration.  Then, in the target&#8217;s <tt class="docutils literal"><span class="pre">TargetInfo</span></tt>
library, the target should define that object and use the <tt class="docutils literal"><span class="pre">RegisterTarget</span></tt>
template to register the target.  For example, the Sparc registration code
looks like this:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Target</span> <span class="n">llvm</span><span class="o">::</span><span class="n">TheSparcTarget</span><span class="p">;</span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeSparcTargetInfo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">RegisterTarget</span><span class="o">&lt;</span><span class="n">Triple</span><span class="o">::</span><span class="n">sparc</span><span class="p">,</span> <span class="cm">/*HasJIT=*/</span><span class="nb">false</span><span class="o">&gt;</span>
    <span class="n">X</span><span class="p">(</span><span class="n">TheSparcTarget</span><span class="p">,</span> <span class="s">&quot;sparc&quot;</span><span class="p">,</span> <span class="s">&quot;Sparc&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This allows the <tt class="docutils literal"><span class="pre">TargetRegistry</span></tt> to look up the target by name or by target
triple.  In addition, most targets will also register additional features which
are available in separate libraries.  These registration steps are separate,
because some clients may wish to only link in some parts of the target &#8212; the
JIT code generator does not require the use of the assembler printer, for
example.  Here is an example of registering the Sparc assembly printer:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeSparcAsmPrinter</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">RegisterAsmPrinter</span><span class="o">&lt;</span><span class="n">SparcAsmPrinter</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="n">TheSparcTarget</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For more information, see &#8220;<a class="reference external" href="http://llvm.org/doxygen/TargetRegistry_8h-source.html">llvm/Target/TargetRegistry.h</a>&#8221;.</p>
</div>
<div class="section" id="register-set-and-register-classes">
<h2><a class="toc-backref" href="#id10">Register Set and Register Classes</a><a class="headerlink" href="#register-set-and-register-classes" title="Permalink to this headline">¶</a></h2>
<p>You should describe a concrete target-specific class that represents the
register file of a target machine.  This class is called <tt class="docutils literal"><span class="pre">XXXRegisterInfo</span></tt>
(where <tt class="docutils literal"><span class="pre">XXX</span></tt> identifies the target) and represents the class register file
data that is used for register allocation.  It also describes the interactions
between registers.</p>
<p>You also need to define register classes to categorize related registers.  A
register class should be added for groups of registers that are all treated the
same way for some instruction.  Typical examples are register classes for
integer, floating-point, or vector registers.  A register allocator allows an
instruction to use any register in a specified register class to perform the
instruction in a similar manner.  Register classes allocate virtual registers
to instructions from these sets, and register classes let the
target-independent register allocator automatically choose the actual
registers.</p>
<p>Much of the code for registers, including register definition, register
aliases, and register classes, is generated by TableGen from
<tt class="docutils literal"><span class="pre">XXXRegisterInfo.td</span></tt> input files and placed in <tt class="docutils literal"><span class="pre">XXXGenRegisterInfo.h.inc</span></tt>
and <tt class="docutils literal"><span class="pre">XXXGenRegisterInfo.inc</span></tt> output files.  Some of the code in the
implementation of <tt class="docutils literal"><span class="pre">XXXRegisterInfo</span></tt> requires hand-coding.</p>
<div class="section" id="defining-a-register">
<h3><a class="toc-backref" href="#id11">Defining a Register</a><a class="headerlink" href="#defining-a-register" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">XXXRegisterInfo.td</span></tt> file typically starts with register definitions for
a target machine.  The <tt class="docutils literal"><span class="pre">Register</span></tt> class (specified in <tt class="docutils literal"><span class="pre">Target.td</span></tt>) is used
to define an object for each register.  The specified string <tt class="docutils literal"><span class="pre">n</span></tt> becomes the
<tt class="docutils literal"><span class="pre">Name</span></tt> of the register.  The basic <tt class="docutils literal"><span class="pre">Register</span></tt> object does not have any
subregisters and does not specify any aliases.</p>
<div class="highlight-llvm"><pre>class Register&lt;string n&gt; {
  string Namespace = "";
  string AsmName = n;
  string Name = n;
  int SpillSize = 0;
  int SpillAlignment = 0;
  list&lt;Register&gt; Aliases = [];
  list&lt;Register&gt; SubRegs = [];
  list&lt;int&gt; DwarfNumbers = [];
}</pre>
</div>
<p>For example, in the <tt class="docutils literal"><span class="pre">X86RegisterInfo.td</span></tt> file, there are register definitions
that utilize the <tt class="docutils literal"><span class="pre">Register</span></tt> class, such as:</p>
<div class="highlight-llvm"><pre>def AL : Register&lt;"AL"&gt;, DwarfRegNum&lt;[0, 0, 0]&gt;;</pre>
</div>
<p>This defines the register <tt class="docutils literal"><span class="pre">AL</span></tt> and assigns it values (with <tt class="docutils literal"><span class="pre">DwarfRegNum</span></tt>)
that are used by <tt class="docutils literal"><span class="pre">gcc</span></tt>, <tt class="docutils literal"><span class="pre">gdb</span></tt>, or a debug information writer to identify a
register.  For register <tt class="docutils literal"><span class="pre">AL</span></tt>, <tt class="docutils literal"><span class="pre">DwarfRegNum</span></tt> takes an array of 3 values
representing 3 different modes: the first element is for X86-64, the second for
exception handling (EH) on X86-32, and the third is generic. -1 is a special
Dwarf number that indicates the gcc number is undefined, and -2 indicates the
register number is invalid for this mode.</p>
<p>From the previously described line in the <tt class="docutils literal"><span class="pre">X86RegisterInfo.td</span></tt> file, TableGen
generates this code in the <tt class="docutils literal"><span class="pre">X86GenRegisterInfo.inc</span></tt> file:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">GR8</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">X86</span><span class="o">::</span><span class="n">AL</span><span class="p">,</span> <span class="p">...</span> <span class="p">};</span>

<span class="k">const</span> <span class="kt">unsigned</span> <span class="n">AL_AliasSet</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">X86</span><span class="o">::</span><span class="n">AX</span><span class="p">,</span> <span class="n">X86</span><span class="o">::</span><span class="n">EAX</span><span class="p">,</span> <span class="n">X86</span><span class="o">::</span><span class="n">RAX</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>

<span class="k">const</span> <span class="n">TargetRegisterDesc</span> <span class="n">RegisterDescriptors</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">{</span> <span class="s">&quot;AL&quot;</span><span class="p">,</span> <span class="s">&quot;AL&quot;</span><span class="p">,</span> <span class="n">AL_AliasSet</span><span class="p">,</span> <span class="n">Empty_SubRegsSet</span><span class="p">,</span> <span class="n">Empty_SubRegsSet</span><span class="p">,</span> <span class="n">AL_SuperRegsSet</span> <span class="p">},</span> <span class="p">...</span>
</pre></div>
</div>
<p>From the register info file, TableGen generates a <tt class="docutils literal"><span class="pre">TargetRegisterDesc</span></tt> object
for each register.  <tt class="docutils literal"><span class="pre">TargetRegisterDesc</span></tt> is defined in
<tt class="docutils literal"><span class="pre">include/llvm/Target/TargetRegisterInfo.h</span></tt> with the following fields:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">TargetRegisterDesc</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span>     <span class="o">*</span><span class="n">AsmName</span><span class="p">;</span>      <span class="c1">// Assembly language name for the register</span>
  <span class="k">const</span> <span class="kt">char</span>     <span class="o">*</span><span class="n">Name</span><span class="p">;</span>         <span class="c1">// Printable name for the reg (for debugging)</span>
  <span class="k">const</span> <span class="kt">unsigned</span> <span class="o">*</span><span class="n">AliasSet</span><span class="p">;</span>     <span class="c1">// Register Alias Set</span>
  <span class="k">const</span> <span class="kt">unsigned</span> <span class="o">*</span><span class="n">SubRegs</span><span class="p">;</span>      <span class="c1">// Sub-register set</span>
  <span class="k">const</span> <span class="kt">unsigned</span> <span class="o">*</span><span class="n">ImmSubRegs</span><span class="p">;</span>   <span class="c1">// Immediate sub-register set</span>
  <span class="k">const</span> <span class="kt">unsigned</span> <span class="o">*</span><span class="n">SuperRegs</span><span class="p">;</span>    <span class="c1">// Super-register set</span>
<span class="p">};</span>
</pre></div>
</div>
<p>TableGen uses the entire target description file (<tt class="docutils literal"><span class="pre">.td</span></tt>) to determine text
names for the register (in the <tt class="docutils literal"><span class="pre">AsmName</span></tt> and <tt class="docutils literal"><span class="pre">Name</span></tt> fields of
<tt class="docutils literal"><span class="pre">TargetRegisterDesc</span></tt>) and the relationships of other registers to the defined
register (in the other <tt class="docutils literal"><span class="pre">TargetRegisterDesc</span></tt> fields).  In this example, other
definitions establish the registers &#8220;<tt class="docutils literal"><span class="pre">AX</span></tt>&#8221;, &#8220;<tt class="docutils literal"><span class="pre">EAX</span></tt>&#8221;, and &#8220;<tt class="docutils literal"><span class="pre">RAX</span></tt>&#8221; as
aliases for one another, so TableGen generates a null-terminated array
(<tt class="docutils literal"><span class="pre">AL_AliasSet</span></tt>) for this register alias set.</p>
<p>The <tt class="docutils literal"><span class="pre">Register</span></tt> class is commonly used as a base class for more complex
classes.  In <tt class="docutils literal"><span class="pre">Target.td</span></tt>, the <tt class="docutils literal"><span class="pre">Register</span></tt> class is the base for the
<tt class="docutils literal"><span class="pre">RegisterWithSubRegs</span></tt> class that is used to define registers that need to
specify subregisters in the <tt class="docutils literal"><span class="pre">SubRegs</span></tt> list, as shown here:</p>
<div class="highlight-llvm"><pre>class RegisterWithSubRegs&lt;string n, list&lt;Register&gt; subregs&gt; : Register&lt;n&gt; {
  let SubRegs = subregs;
}</pre>
</div>
<p>In <tt class="docutils literal"><span class="pre">SparcRegisterInfo.td</span></tt>, additional register classes are defined for SPARC:
a <tt class="docutils literal"><span class="pre">Register</span></tt> subclass, <tt class="docutils literal"><span class="pre">SparcReg</span></tt>, and further subclasses: <tt class="docutils literal"><span class="pre">Ri</span></tt>, <tt class="docutils literal"><span class="pre">Rf</span></tt>,
and <tt class="docutils literal"><span class="pre">Rd</span></tt>.  SPARC registers are identified by 5-bit ID numbers, which is a
feature common to these subclasses.  Note the use of &#8220;<tt class="docutils literal"><span class="pre">let</span></tt>&#8221; expressions to
override values that are initially defined in a superclass (such as <tt class="docutils literal"><span class="pre">SubRegs</span></tt>
field in the <tt class="docutils literal"><span class="pre">Rd</span></tt> class).</p>
<div class="highlight-llvm"><pre>class SparcReg&lt;string n&gt; : Register&lt;n&gt; {
  field bits&lt;5&gt; Num;
  let Namespace = "SP";
}
// Ri - 32-bit integer registers
class Ri&lt;bits&lt;5&gt; num, string n&gt; :
SparcReg&lt;n&gt; {
  let Num = num;
}
// Rf - 32-bit floating-point registers
class Rf&lt;bits&lt;5&gt; num, string n&gt; :
SparcReg&lt;n&gt; {
  let Num = num;
}
// Rd - Slots in the FP register file for 64-bit floating-point values.
class Rd&lt;bits&lt;5&gt; num, string n, list&lt;Register&gt; subregs&gt; : SparcReg&lt;n&gt; {
  let Num = num;
  let SubRegs = subregs;
}</pre>
</div>
<p>In the <tt class="docutils literal"><span class="pre">SparcRegisterInfo.td</span></tt> file, there are register definitions that
utilize these subclasses of <tt class="docutils literal"><span class="pre">Register</span></tt>, such as:</p>
<div class="highlight-llvm"><pre>def G0 : Ri&lt; 0, "G0"&gt;, DwarfRegNum&lt;[0]&gt;;
def G1 : Ri&lt; 1, "G1"&gt;, DwarfRegNum&lt;[1]&gt;;
...
def F0 : Rf&lt; 0, "F0"&gt;, DwarfRegNum&lt;[32]&gt;;
def F1 : Rf&lt; 1, "F1"&gt;, DwarfRegNum&lt;[33]&gt;;
...
def D0 : Rd&lt; 0, "F0", [F0, F1]&gt;, DwarfRegNum&lt;[32]&gt;;
def D1 : Rd&lt; 2, "F2", [F2, F3]&gt;, DwarfRegNum&lt;[34]&gt;;</pre>
</div>
<p>The last two registers shown above (<tt class="docutils literal"><span class="pre">D0</span></tt> and <tt class="docutils literal"><span class="pre">D1</span></tt>) are double-precision
floating-point registers that are aliases for pairs of single-precision
floating-point sub-registers.  In addition to aliases, the sub-register and
super-register relationships of the defined register are in fields of a
register&#8217;s <tt class="docutils literal"><span class="pre">TargetRegisterDesc</span></tt>.</p>
</div>
<div class="section" id="defining-a-register-class">
<h3><a class="toc-backref" href="#id12">Defining a Register Class</a><a class="headerlink" href="#defining-a-register-class" title="Permalink to this headline">¶</a></h3>
<p>The <tt class="docutils literal"><span class="pre">RegisterClass</span></tt> class (specified in <tt class="docutils literal"><span class="pre">Target.td</span></tt>) is used to define an
object that represents a group of related registers and also defines the
default allocation order of the registers.  A target description file
<tt class="docutils literal"><span class="pre">XXXRegisterInfo.td</span></tt> that uses <tt class="docutils literal"><span class="pre">Target.td</span></tt> can construct register classes
using the following class:</p>
<div class="highlight-llvm"><pre>class RegisterClass&lt;string namespace,
list&lt;ValueType&gt; regTypes, int alignment, dag regList&gt; {
  string Namespace = namespace;
  list&lt;ValueType&gt; RegTypes = regTypes;
  int Size = 0;  // spill size, in bits; zero lets tblgen pick the size
  int Alignment = alignment;

  // CopyCost is the cost of copying a value between two registers
  // default value 1 means a single instruction
  // A negative value means copying is extremely expensive or impossible
  int CopyCost = 1;
  dag MemberList = regList;

  // for register classes that are subregisters of this class
  list&lt;RegisterClass&gt; SubRegClassList = [];

  code MethodProtos = [{}];  // to insert arbitrary code
  code MethodBodies = [{}];
}</pre>
</div>
<p>To define a <tt class="docutils literal"><span class="pre">RegisterClass</span></tt>, use the following 4 arguments:</p>
<ul class="simple">
<li>The first argument of the definition is the name of the namespace.</li>
<li>The second argument is a list of <tt class="docutils literal"><span class="pre">ValueType</span></tt> register type values that are
defined in <tt class="docutils literal"><span class="pre">include/llvm/CodeGen/ValueTypes.td</span></tt>.  Defined values include
integer types (such as <tt class="docutils literal"><span class="pre">i16</span></tt>, <tt class="docutils literal"><span class="pre">i32</span></tt>, and <tt class="docutils literal"><span class="pre">i1</span></tt> for Boolean),
floating-point types (<tt class="docutils literal"><span class="pre">f32</span></tt>, <tt class="docutils literal"><span class="pre">f64</span></tt>), and vector types (for example,
<tt class="docutils literal"><span class="pre">v8i16</span></tt> for an <tt class="docutils literal"><span class="pre">8</span> <span class="pre">x</span> <span class="pre">i16</span></tt> vector).  All registers in a <tt class="docutils literal"><span class="pre">RegisterClass</span></tt>
must have the same <tt class="docutils literal"><span class="pre">ValueType</span></tt>, but some registers may store vector data in
different configurations.  For example a register that can process a 128-bit
vector may be able to handle 16 8-bit integer elements, 8 16-bit integers, 4
32-bit integers, and so on.</li>
<li>The third argument of the <tt class="docutils literal"><span class="pre">RegisterClass</span></tt> definition specifies the
alignment required of the registers when they are stored or loaded to
memory.</li>
<li>The final argument, <tt class="docutils literal"><span class="pre">regList</span></tt>, specifies which registers are in this class.
If an alternative allocation order method is not specified, then <tt class="docutils literal"><span class="pre">regList</span></tt>
also defines the order of allocation used by the register allocator.  Besides
simply listing registers with <tt class="docutils literal"><span class="pre">(add</span> <span class="pre">R0,</span> <span class="pre">R1,</span> <span class="pre">...)</span></tt>, more advanced set
operators are available.  See <tt class="docutils literal"><span class="pre">include/llvm/Target/Target.td</span></tt> for more
information.</li>
</ul>
<p>In <tt class="docutils literal"><span class="pre">SparcRegisterInfo.td</span></tt>, three <tt class="docutils literal"><span class="pre">RegisterClass</span></tt> objects are defined:
<tt class="docutils literal"><span class="pre">FPRegs</span></tt>, <tt class="docutils literal"><span class="pre">DFPRegs</span></tt>, and <tt class="docutils literal"><span class="pre">IntRegs</span></tt>.  For all three register classes, the
first argument defines the namespace with the string &#8220;<tt class="docutils literal"><span class="pre">SP</span></tt>&#8221;.  <tt class="docutils literal"><span class="pre">FPRegs</span></tt>
defines a group of 32 single-precision floating-point registers (<tt class="docutils literal"><span class="pre">F0</span></tt> to
<tt class="docutils literal"><span class="pre">F31</span></tt>); <tt class="docutils literal"><span class="pre">DFPRegs</span></tt> defines a group of 16 double-precision registers
(<tt class="docutils literal"><span class="pre">D0-D15</span></tt>).</p>
<div class="highlight-llvm"><pre>// F0, F1, F2, ..., F31
def FPRegs : RegisterClass&lt;"SP", [f32], 32, (sequence "F%u", 0, 31)&gt;;

def DFPRegs : RegisterClass&lt;"SP", [f64], 64,
                            (add D0, D1, D2, D3, D4, D5, D6, D7, D8,
                                 D9, D10, D11, D12, D13, D14, D15)&gt;;

def IntRegs : RegisterClass&lt;"SP", [i32], 32,
    (add L0, L1, L2, L3, L4, L5, L6, L7,
         I0, I1, I2, I3, I4, I5,
         O0, O1, O2, O3, O4, O5, O7,
         G1,
         // Non-allocatable regs:
         G2, G3, G4,
         O6,        // stack ptr
         I6,        // frame ptr
         I7,        // return address
         G0,        // constant zero
         G5, G6, G7 // reserved for kernel
    )&gt;;</pre>
</div>
<p>Using <tt class="docutils literal"><span class="pre">SparcRegisterInfo.td</span></tt> with TableGen generates several output files
that are intended for inclusion in other source code that you write.
<tt class="docutils literal"><span class="pre">SparcRegisterInfo.td</span></tt> generates <tt class="docutils literal"><span class="pre">SparcGenRegisterInfo.h.inc</span></tt>, which should
be included in the header file for the implementation of the SPARC register
implementation that you write (<tt class="docutils literal"><span class="pre">SparcRegisterInfo.h</span></tt>).  In
<tt class="docutils literal"><span class="pre">SparcGenRegisterInfo.h.inc</span></tt> a new structure is defined called
<tt class="docutils literal"><span class="pre">SparcGenRegisterInfo</span></tt> that uses <tt class="docutils literal"><span class="pre">TargetRegisterInfo</span></tt> as its base.  It also
specifies types, based upon the defined register classes: <tt class="docutils literal"><span class="pre">DFPRegsClass</span></tt>,
<tt class="docutils literal"><span class="pre">FPRegsClass</span></tt>, and <tt class="docutils literal"><span class="pre">IntRegsClass</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">SparcRegisterInfo.td</span></tt> also generates <tt class="docutils literal"><span class="pre">SparcGenRegisterInfo.inc</span></tt>, which is
included at the bottom of <tt class="docutils literal"><span class="pre">SparcRegisterInfo.cpp</span></tt>, the SPARC register
implementation.  The code below shows only the generated integer registers and
associated register classes.  The order of registers in <tt class="docutils literal"><span class="pre">IntRegs</span></tt> reflects
the order in the definition of <tt class="docutils literal"><span class="pre">IntRegs</span></tt> in the target description file.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// IntRegs Register Class...</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">IntRegs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">SP</span><span class="o">::</span><span class="n">L0</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">L1</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">L2</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">L3</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">L4</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">L5</span><span class="p">,</span>
  <span class="n">SP</span><span class="o">::</span><span class="n">L6</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">L7</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">I0</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">I1</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">I2</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">I3</span><span class="p">,</span>
  <span class="n">SP</span><span class="o">::</span><span class="n">I4</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">I5</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">O0</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">O1</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">O2</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">O3</span><span class="p">,</span>
  <span class="n">SP</span><span class="o">::</span><span class="n">O4</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">O5</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">O7</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">G1</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">G2</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">G3</span><span class="p">,</span>
  <span class="n">SP</span><span class="o">::</span><span class="n">G4</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">O6</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">I6</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">I7</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">G0</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">G5</span><span class="p">,</span>
  <span class="n">SP</span><span class="o">::</span><span class="n">G6</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">G7</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// IntRegsVTs Register Class Value Types...</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">MVT</span><span class="o">::</span><span class="n">ValueType</span> <span class="n">IntRegsVTs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span>
<span class="p">};</span>

<span class="k">namespace</span> <span class="n">SP</span> <span class="p">{</span>   <span class="c1">// Register class instances</span>
  <span class="n">DFPRegsClass</span>    <span class="n">DFPRegsRegClass</span><span class="p">;</span>
  <span class="n">FPRegsClass</span>     <span class="n">FPRegsRegClass</span><span class="p">;</span>
  <span class="n">IntRegsClass</span>    <span class="n">IntRegsRegClass</span><span class="p">;</span>
<span class="p">...</span>
  <span class="c1">// IntRegs Sub-register Classess...</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">TargetRegisterClass</span><span class="o">*</span> <span class="k">const</span> <span class="n">IntRegsSubRegClasses</span> <span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nb">NULL</span>
  <span class="p">};</span>
<span class="p">...</span>
  <span class="c1">// IntRegs Super-register Classess...</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">TargetRegisterClass</span><span class="o">*</span> <span class="k">const</span> <span class="n">IntRegsSuperRegClasses</span> <span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nb">NULL</span>
  <span class="p">};</span>
<span class="p">...</span>
  <span class="c1">// IntRegs Register Class sub-classes...</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">TargetRegisterClass</span><span class="o">*</span> <span class="k">const</span> <span class="n">IntRegsSubclasses</span> <span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nb">NULL</span>
  <span class="p">};</span>
<span class="p">...</span>
  <span class="c1">// IntRegs Register Class super-classes...</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">TargetRegisterClass</span><span class="o">*</span> <span class="k">const</span> <span class="n">IntRegsSuperclasses</span> <span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nb">NULL</span>
  <span class="p">};</span>

  <span class="n">IntRegsClass</span><span class="o">::</span><span class="n">IntRegsClass</span><span class="p">()</span> <span class="o">:</span> <span class="n">TargetRegisterClass</span><span class="p">(</span><span class="n">IntRegsRegClassID</span><span class="p">,</span>
    <span class="n">IntRegsVTs</span><span class="p">,</span> <span class="n">IntRegsSubclasses</span><span class="p">,</span> <span class="n">IntRegsSuperclasses</span><span class="p">,</span> <span class="n">IntRegsSubRegClasses</span><span class="p">,</span>
    <span class="n">IntRegsSuperRegClasses</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">IntRegs</span><span class="p">,</span> <span class="n">IntRegs</span> <span class="o">+</span> <span class="mi">32</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The register allocators will avoid using reserved registers, and callee saved
registers are not used until all the volatile registers have been used.  That
is usually good enough, but in some cases it may be necessary to provide custom
allocation orders.</p>
</div>
<div class="section" id="implement-a-subclass-of-targetregisterinfo">
<h3><a class="toc-backref" href="#id13">Implement a subclass of <tt class="docutils literal"><span class="pre">TargetRegisterInfo</span></tt></a><a class="headerlink" href="#implement-a-subclass-of-targetregisterinfo" title="Permalink to this headline">¶</a></h3>
<p>The final step is to hand code portions of <tt class="docutils literal"><span class="pre">XXXRegisterInfo</span></tt>, which
implements the interface described in <tt class="docutils literal"><span class="pre">TargetRegisterInfo.h</span></tt> (see
<a class="reference internal" href="CodeGenerator.html#targetregisterinfo"><em>The TargetRegisterInfo class</em></a>).  These functions return <tt class="docutils literal"><span class="pre">0</span></tt>, <tt class="docutils literal"><span class="pre">NULL</span></tt>, or
<tt class="docutils literal"><span class="pre">false</span></tt>, unless overridden.  Here is a list of functions that are overridden
for the SPARC implementation in <tt class="docutils literal"><span class="pre">SparcRegisterInfo.cpp</span></tt>:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">getCalleeSavedRegs</span></tt> &#8212; Returns a list of callee-saved registers in the
order of the desired callee-save stack frame offset.</li>
<li><tt class="docutils literal"><span class="pre">getReservedRegs</span></tt> &#8212; Returns a bitset indexed by physical register
numbers, indicating if a particular register is unavailable.</li>
<li><tt class="docutils literal"><span class="pre">hasFP</span></tt> &#8212; Return a Boolean indicating if a function should have a
dedicated frame pointer register.</li>
<li><tt class="docutils literal"><span class="pre">eliminateCallFramePseudoInstr</span></tt> &#8212; If call frame setup or destroy pseudo
instructions are used, this can be called to eliminate them.</li>
<li><tt class="docutils literal"><span class="pre">eliminateFrameIndex</span></tt> &#8212; Eliminate abstract frame indices from
instructions that may use them.</li>
<li><tt class="docutils literal"><span class="pre">emitPrologue</span></tt> &#8212; Insert prologue code into the function.</li>
<li><tt class="docutils literal"><span class="pre">emitEpilogue</span></tt> &#8212; Insert epilogue code into the function.</li>
</ul>
</div>
</div>
<div class="section" id="instruction-set">
<span id="id1"></span><h2><a class="toc-backref" href="#id14">Instruction Set</a><a class="headerlink" href="#instruction-set" title="Permalink to this headline">¶</a></h2>
<p>During the early stages of code generation, the LLVM IR code is converted to a
<tt class="docutils literal"><span class="pre">SelectionDAG</span></tt> with nodes that are instances of the <tt class="docutils literal"><span class="pre">SDNode</span></tt> class
containing target instructions.  An <tt class="docutils literal"><span class="pre">SDNode</span></tt> has an opcode, operands, type
requirements, and operation properties.  For example, is an operation
commutative, does an operation load from memory.  The various operation node
types are described in the <tt class="docutils literal"><span class="pre">include/llvm/CodeGen/SelectionDAGNodes.h</span></tt> file
(values of the <tt class="docutils literal"><span class="pre">NodeType</span></tt> enum in the <tt class="docutils literal"><span class="pre">ISD</span></tt> namespace).</p>
<p>TableGen uses the following target description (<tt class="docutils literal"><span class="pre">.td</span></tt>) input files to
generate much of the code for instruction definition:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">Target.td</span></tt> &#8212; Where the <tt class="docutils literal"><span class="pre">Instruction</span></tt>, <tt class="docutils literal"><span class="pre">Operand</span></tt>, <tt class="docutils literal"><span class="pre">InstrInfo</span></tt>, and
other fundamental classes are defined.</li>
<li><tt class="docutils literal"><span class="pre">TargetSelectionDAG.td</span></tt> &#8212; Used by <tt class="docutils literal"><span class="pre">SelectionDAG</span></tt> instruction selection
generators, contains <tt class="docutils literal"><span class="pre">SDTC*</span></tt> classes (selection DAG type constraint),
definitions of <tt class="docutils literal"><span class="pre">SelectionDAG</span></tt> nodes (such as <tt class="docutils literal"><span class="pre">imm</span></tt>, <tt class="docutils literal"><span class="pre">cond</span></tt>, <tt class="docutils literal"><span class="pre">bb</span></tt>,
<tt class="docutils literal"><span class="pre">add</span></tt>, <tt class="docutils literal"><span class="pre">fadd</span></tt>, <tt class="docutils literal"><span class="pre">sub</span></tt>), and pattern support (<tt class="docutils literal"><span class="pre">Pattern</span></tt>, <tt class="docutils literal"><span class="pre">Pat</span></tt>,
<tt class="docutils literal"><span class="pre">PatFrag</span></tt>, <tt class="docutils literal"><span class="pre">PatLeaf</span></tt>, <tt class="docutils literal"><span class="pre">ComplexPattern</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">XXXInstrFormats.td</span></tt> &#8212; Patterns for definitions of target-specific
instructions.</li>
<li><tt class="docutils literal"><span class="pre">XXXInstrInfo.td</span></tt> &#8212; Target-specific definitions of instruction templates,
condition codes, and instructions of an instruction set.  For architecture
modifications, a different file name may be used.  For example, for Pentium
with SSE instruction, this file is <tt class="docutils literal"><span class="pre">X86InstrSSE.td</span></tt>, and for Pentium with
MMX, this file is <tt class="docutils literal"><span class="pre">X86InstrMMX.td</span></tt>.</li>
</ul>
<p>There is also a target-specific <tt class="docutils literal"><span class="pre">XXX.td</span></tt> file, where <tt class="docutils literal"><span class="pre">XXX</span></tt> is the name of
the target.  The <tt class="docutils literal"><span class="pre">XXX.td</span></tt> file includes the other <tt class="docutils literal"><span class="pre">.td</span></tt> input files, but
its contents are only directly important for subtargets.</p>
<p>You should describe a concrete target-specific class <tt class="docutils literal"><span class="pre">XXXInstrInfo</span></tt> that
represents machine instructions supported by a target machine.
<tt class="docutils literal"><span class="pre">XXXInstrInfo</span></tt> contains an array of <tt class="docutils literal"><span class="pre">XXXInstrDescriptor</span></tt> objects, each of
which describes one instruction.  An instruction descriptor defines:</p>
<ul class="simple">
<li>Opcode mnemonic</li>
<li>Number of operands</li>
<li>List of implicit register definitions and uses</li>
<li>Target-independent properties (such as memory access, is commutable)</li>
<li>Target-specific flags</li>
</ul>
<p>The Instruction class (defined in <tt class="docutils literal"><span class="pre">Target.td</span></tt>) is mostly used as a base for
more complex instruction classes.</p>
<div class="highlight-llvm"><pre>class Instruction {
  string Namespace = "";
  dag OutOperandList;    // A dag containing the MI def operand list.
  dag InOperandList;     // A dag containing the MI use operand list.
  string AsmString = ""; // The .s format to print the instruction with.
  list&lt;dag&gt; Pattern;     // Set to the DAG pattern for this instruction.
  list&lt;Register&gt; Uses = [];
  list&lt;Register&gt; Defs = [];
  list&lt;Predicate&gt; Predicates = [];  // predicates turned into isel match code
  ... remainder not shown for space ...
}</pre>
</div>
<p>A <tt class="docutils literal"><span class="pre">SelectionDAG</span></tt> node (<tt class="docutils literal"><span class="pre">SDNode</span></tt>) should contain an object representing a
target-specific instruction that is defined in <tt class="docutils literal"><span class="pre">XXXInstrInfo.td</span></tt>.  The
instruction objects should represent instructions from the architecture manual
of the target machine (such as the SPARC Architecture Manual for the SPARC
target).</p>
<p>A single instruction from the architecture manual is often modeled as multiple
target instructions, depending upon its operands.  For example, a manual might
describe an add instruction that takes a register or an immediate operand.  An
LLVM target could model this with two instructions named <tt class="docutils literal"><span class="pre">ADDri</span></tt> and
<tt class="docutils literal"><span class="pre">ADDrr</span></tt>.</p>
<p>You should define a class for each instruction category and define each opcode
as a subclass of the category with appropriate parameters such as the fixed
binary encoding of opcodes and extended opcodes.  You should map the register
bits to the bits of the instruction in which they are encoded (for the JIT).
Also you should specify how the instruction should be printed when the
automatic assembly printer is used.</p>
<p>As is described in the SPARC Architecture Manual, Version 8, there are three
major 32-bit formats for instructions.  Format 1 is only for the <tt class="docutils literal"><span class="pre">CALL</span></tt>
instruction.  Format 2 is for branch on condition codes and <tt class="docutils literal"><span class="pre">SETHI</span></tt> (set high
bits of a register) instructions.  Format 3 is for other instructions.</p>
<p>Each of these formats has corresponding classes in <tt class="docutils literal"><span class="pre">SparcInstrFormat.td</span></tt>.
<tt class="docutils literal"><span class="pre">InstSP</span></tt> is a base class for other instruction classes.  Additional base
classes are specified for more precise formats: for example in
<tt class="docutils literal"><span class="pre">SparcInstrFormat.td</span></tt>, <tt class="docutils literal"><span class="pre">F2_1</span></tt> is for <tt class="docutils literal"><span class="pre">SETHI</span></tt>, and <tt class="docutils literal"><span class="pre">F2_2</span></tt> is for
branches.  There are three other base classes: <tt class="docutils literal"><span class="pre">F3_1</span></tt> for register/register
operations, <tt class="docutils literal"><span class="pre">F3_2</span></tt> for register/immediate operations, and <tt class="docutils literal"><span class="pre">F3_3</span></tt> for
floating-point operations.  <tt class="docutils literal"><span class="pre">SparcInstrInfo.td</span></tt> also adds the base class
<tt class="docutils literal"><span class="pre">Pseudo</span></tt> for synthetic SPARC instructions.</p>
<p><tt class="docutils literal"><span class="pre">SparcInstrInfo.td</span></tt> largely consists of operand and instruction definitions
for the SPARC target.  In <tt class="docutils literal"><span class="pre">SparcInstrInfo.td</span></tt>, the following target
description file entry, <tt class="docutils literal"><span class="pre">LDrr</span></tt>, defines the Load Integer instruction for a
Word (the <tt class="docutils literal"><span class="pre">LD</span></tt> SPARC opcode) from a memory address to a register.  The first
parameter, the value 3 (<tt class="docutils literal"><span class="pre">11</span></tt><sub>2</sub>), is the operation value for this
category of operation.  The second parameter (<tt class="docutils literal"><span class="pre">000000</span></tt><sub>2</sub>) is the
specific operation value for <tt class="docutils literal"><span class="pre">LD</span></tt>/Load Word.  The third parameter is the
output destination, which is a register operand and defined in the <tt class="docutils literal"><span class="pre">Register</span></tt>
target description file (<tt class="docutils literal"><span class="pre">IntRegs</span></tt>).</p>
<div class="highlight-llvm"><pre>def LDrr : F3_1 &lt;3, 0b000000, (outs IntRegs:$dst), (ins MEMrr:$addr),
                 "ld [$addr], $dst",
                 [(set i32:$dst, (load ADDRrr:$addr))]&gt;;</pre>
</div>
<p>The fourth parameter is the input source, which uses the address operand
<tt class="docutils literal"><span class="pre">MEMrr</span></tt> that is defined earlier in <tt class="docutils literal"><span class="pre">SparcInstrInfo.td</span></tt>:</p>
<div class="highlight-llvm"><pre>def MEMrr : Operand&lt;i32&gt; {
  let PrintMethod = "printMemOperand";
  let MIOperandInfo = (ops IntRegs, IntRegs);
}</pre>
</div>
<p>The fifth parameter is a string that is used by the assembly printer and can be
left as an empty string until the assembly printer interface is implemented.
The sixth and final parameter is the pattern used to match the instruction
during the SelectionDAG Select Phase described in <a class="reference internal" href="CodeGenerator.html"><em>The LLVM Target-Independent Code Generator</em></a>.
This parameter is detailed in the next section, <a class="reference internal" href="#instruction-selector"><em>Instruction Selector</em></a>.</p>
<p>Instruction class definitions are not overloaded for different operand types,
so separate versions of instructions are needed for register, memory, or
immediate value operands.  For example, to perform a Load Integer instruction
for a Word from an immediate operand to a register, the following instruction
class is defined:</p>
<div class="highlight-llvm"><pre>def LDri : F3_2 &lt;3, 0b000000, (outs IntRegs:$dst), (ins MEMri:$addr),
                 "ld [$addr], $dst",
                 [(set i32:$dst, (load ADDRri:$addr))]&gt;;</pre>
</div>
<p>Writing these definitions for so many similar instructions can involve a lot of
cut and paste.  In <tt class="docutils literal"><span class="pre">.td</span></tt> files, the <tt class="docutils literal"><span class="pre">multiclass</span></tt> directive enables the
creation of templates to define several instruction classes at once (using the
<tt class="docutils literal"><span class="pre">defm</span></tt> directive).  For example in <tt class="docutils literal"><span class="pre">SparcInstrInfo.td</span></tt>, the <tt class="docutils literal"><span class="pre">multiclass</span></tt>
pattern <tt class="docutils literal"><span class="pre">F3_12</span></tt> is defined to create 2 instruction classes each time
<tt class="docutils literal"><span class="pre">F3_12</span></tt> is invoked:</p>
<div class="highlight-llvm"><pre>multiclass F3_12 &lt;string OpcStr, bits&lt;6&gt; Op3Val, SDNode OpNode&gt; {
  def rr  : F3_1 &lt;2, Op3Val,
                 (outs IntRegs:$dst), (ins IntRegs:$b, IntRegs:$c),
                 !strconcat(OpcStr, " $b, $c, $dst"),
                 [(set i32:$dst, (OpNode i32:$b, i32:$c))]&gt;;
  def ri  : F3_2 &lt;2, Op3Val,
                 (outs IntRegs:$dst), (ins IntRegs:$b, i32imm:$c),
                 !strconcat(OpcStr, " $b, $c, $dst"),
                 [(set i32:$dst, (OpNode i32:$b, simm13:$c))]&gt;;
}</pre>
</div>
<p>So when the <tt class="docutils literal"><span class="pre">defm</span></tt> directive is used for the <tt class="docutils literal"><span class="pre">XOR</span></tt> and <tt class="docutils literal"><span class="pre">ADD</span></tt>
instructions, as seen below, it creates four instruction objects: <tt class="docutils literal"><span class="pre">XORrr</span></tt>,
<tt class="docutils literal"><span class="pre">XORri</span></tt>, <tt class="docutils literal"><span class="pre">ADDrr</span></tt>, and <tt class="docutils literal"><span class="pre">ADDri</span></tt>.</p>
<div class="highlight-llvm"><pre>defm XOR   : F3_12&lt;"xor", 0b000011, xor&gt;;
defm ADD   : F3_12&lt;"add", 0b000000, add&gt;;</pre>
</div>
<p><tt class="docutils literal"><span class="pre">SparcInstrInfo.td</span></tt> also includes definitions for condition codes that are
referenced by branch instructions.  The following definitions in
<tt class="docutils literal"><span class="pre">SparcInstrInfo.td</span></tt> indicate the bit location of the SPARC condition code.
For example, the 10<sup>th</sup> bit represents the &#8220;greater than&#8221; condition for
integers, and the 22<sup>nd</sup> bit represents the &#8220;greater than&#8221; condition for
floats.</p>
<div class="highlight-llvm"><pre>def ICC_NE  : ICC_VAL&lt; 9&gt;;  // Not Equal
def ICC_E   : ICC_VAL&lt; 1&gt;;  // Equal
def ICC_G   : ICC_VAL&lt;10&gt;;  // Greater
...
def FCC_U   : FCC_VAL&lt;23&gt;;  // Unordered
def FCC_G   : FCC_VAL&lt;22&gt;;  // Greater
def FCC_UG  : FCC_VAL&lt;21&gt;;  // Unordered or Greater
...</pre>
</div>
<p>(Note that <tt class="docutils literal"><span class="pre">Sparc.h</span></tt> also defines enums that correspond to the same SPARC
condition codes.  Care must be taken to ensure the values in <tt class="docutils literal"><span class="pre">Sparc.h</span></tt>
correspond to the values in <tt class="docutils literal"><span class="pre">SparcInstrInfo.td</span></tt>.  I.e., <tt class="docutils literal"><span class="pre">SPCC::ICC_NE</span> <span class="pre">=</span> <span class="pre">9</span></tt>,
<tt class="docutils literal"><span class="pre">SPCC::FCC_U</span> <span class="pre">=</span> <span class="pre">23</span></tt> and so on.)</p>
<div class="section" id="instruction-operand-mapping">
<h3><a class="toc-backref" href="#id15">Instruction Operand Mapping</a><a class="headerlink" href="#instruction-operand-mapping" title="Permalink to this headline">¶</a></h3>
<p>The code generator backend maps instruction operands to fields in the
instruction.  Operands are assigned to unbound fields in the instruction in the
order they are defined.  Fields are bound when they are assigned a value.  For
example, the Sparc target defines the <tt class="docutils literal"><span class="pre">XNORrr</span></tt> instruction as a <tt class="docutils literal"><span class="pre">F3_1</span></tt>
format instruction having three operands.</p>
<div class="highlight-llvm"><pre>def XNORrr  : F3_1&lt;2, 0b000111,
                   (outs IntRegs:$dst), (ins IntRegs:$b, IntRegs:$c),
                   "xnor $b, $c, $dst",
                   [(set i32:$dst, (not (xor i32:$b, i32:$c)))]&gt;;</pre>
</div>
<p>The instruction templates in <tt class="docutils literal"><span class="pre">SparcInstrFormats.td</span></tt> show the base class for
<tt class="docutils literal"><span class="pre">F3_1</span></tt> is <tt class="docutils literal"><span class="pre">InstSP</span></tt>.</p>
<div class="highlight-llvm"><pre>class InstSP&lt;dag outs, dag ins, string asmstr, list&lt;dag&gt; pattern&gt; : Instruction {
  field bits&lt;32&gt; Inst;
  let Namespace = "SP";
  bits&lt;2&gt; op;
  let Inst{31-30} = op;
  dag OutOperandList = outs;
  dag InOperandList = ins;
  let AsmString   = asmstr;
  let Pattern = pattern;
}</pre>
</div>
<p><tt class="docutils literal"><span class="pre">InstSP</span></tt> leaves the <tt class="docutils literal"><span class="pre">op</span></tt> field unbound.</p>
<div class="highlight-llvm"><pre>class F3&lt;dag outs, dag ins, string asmstr, list&lt;dag&gt; pattern&gt;
    : InstSP&lt;outs, ins, asmstr, pattern&gt; {
  bits&lt;5&gt; rd;
  bits&lt;6&gt; op3;
  bits&lt;5&gt; rs1;
  let op{1} = 1;   // Op = 2 or 3
  let Inst{29-25} = rd;
  let Inst{24-19} = op3;
  let Inst{18-14} = rs1;
}</pre>
</div>
<p><tt class="docutils literal"><span class="pre">F3</span></tt> binds the <tt class="docutils literal"><span class="pre">op</span></tt> field and defines the <tt class="docutils literal"><span class="pre">rd</span></tt>, <tt class="docutils literal"><span class="pre">op3</span></tt>, and <tt class="docutils literal"><span class="pre">rs1</span></tt>
fields.  <tt class="docutils literal"><span class="pre">F3</span></tt> format instructions will bind the operands <tt class="docutils literal"><span class="pre">rd</span></tt>, <tt class="docutils literal"><span class="pre">op3</span></tt>, and
<tt class="docutils literal"><span class="pre">rs1</span></tt> fields.</p>
<div class="highlight-llvm"><pre>class F3_1&lt;bits&lt;2&gt; opVal, bits&lt;6&gt; op3val, dag outs, dag ins,
           string asmstr, list&lt;dag&gt; pattern&gt; : F3&lt;outs, ins, asmstr, pattern&gt; {
  bits&lt;8&gt; asi = 0; // asi not currently used
  bits&lt;5&gt; rs2;
  let op         = opVal;
  let op3        = op3val;
  let Inst{13}   = 0;     // i field = 0
  let Inst{12-5} = asi;   // address space identifier
  let Inst{4-0}  = rs2;
}</pre>
</div>
<p><tt class="docutils literal"><span class="pre">F3_1</span></tt> binds the <tt class="docutils literal"><span class="pre">op3</span></tt> field and defines the <tt class="docutils literal"><span class="pre">rs2</span></tt> fields.  <tt class="docutils literal"><span class="pre">F3_1</span></tt>
format instructions will bind the operands to the <tt class="docutils literal"><span class="pre">rd</span></tt>, <tt class="docutils literal"><span class="pre">rs1</span></tt>, and <tt class="docutils literal"><span class="pre">rs2</span></tt>
fields.  This results in the <tt class="docutils literal"><span class="pre">XNORrr</span></tt> instruction binding <tt class="docutils literal"><span class="pre">$dst</span></tt>, <tt class="docutils literal"><span class="pre">$b</span></tt>,
and <tt class="docutils literal"><span class="pre">$c</span></tt> operands to the <tt class="docutils literal"><span class="pre">rd</span></tt>, <tt class="docutils literal"><span class="pre">rs1</span></tt>, and <tt class="docutils literal"><span class="pre">rs2</span></tt> fields respectively.</p>
<div class="section" id="instruction-operand-name-mapping">
<h4><a class="toc-backref" href="#id16">Instruction Operand Name Mapping</a><a class="headerlink" href="#instruction-operand-name-mapping" title="Permalink to this headline">¶</a></h4>
<p>TableGen will also generate a function called getNamedOperandIdx() which
can be used to look up an operand&#8217;s index in a MachineInstr based on its
TableGen name.  Setting the UseNamedOperandTable bit in an instruction&#8217;s
TableGen definition will add all of its operands to an enumeration in the
llvm::XXX:OpName namespace and also add an entry for it into the OperandMap
table, which can be queried using getNamedOperandIdx()</p>
<div class="highlight-llvm"><pre>int DstIndex = SP::getNamedOperandIdx(SP::XNORrr, SP::OpName::dst); // =&gt; 0
int BIndex = SP::getNamedOperandIdx(SP::XNORrr, SP::OpName::b);     // =&gt; 1
int CIndex = SP::getNamedOperandIdx(SP::XNORrr, SP::OpName::c);     // =&gt; 2
int DIndex = SP::getNamedOperandIdx(SP::XNORrr, SP::OpName::d);     // =&gt; -1

...</pre>
</div>
<p>The entries in the OpName enum are taken verbatim from the TableGen definitions,
so operands with lowercase names will have lower case entries in the enum.</p>
<p>To include the getNamedOperandIdx() function in your backend, you will need
to define a few preprocessor macros in XXXInstrInfo.cpp and XXXInstrInfo.h.
For example:</p>
<p>XXXInstrInfo.cpp:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#define GET_INSTRINFO_NAMED_OPS </span><span class="c1">// For getNamedOperandIdx() function</span>
<span class="cp">#include &quot;XXXGenInstrInfo.inc&quot;</span>
</pre></div>
</div>
<p>XXXInstrInfo.h:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#define GET_INSTRINFO_OPERAND_ENUM </span><span class="c1">// For OpName enum</span>
<span class="cp">#include &quot;XXXGenInstrInfo.inc&quot;</span>

<span class="k">namespace</span> <span class="n">XXX</span> <span class="p">{</span>
  <span class="kt">int16_t</span> <span class="n">getNamedOperandIdx</span><span class="p">(</span><span class="kt">uint16_t</span> <span class="n">Opcode</span><span class="p">,</span> <span class="kt">uint16_t</span> <span class="n">NamedIndex</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// End namespace XXX</span>
</pre></div>
</div>
</div>
<div class="section" id="instruction-operand-types">
<h4><a class="toc-backref" href="#id17">Instruction Operand Types</a><a class="headerlink" href="#instruction-operand-types" title="Permalink to this headline">¶</a></h4>
<p>TableGen will also generate an enumeration consisting of all named Operand
types defined in the backend, in the llvm::XXX::OpTypes namespace.
Some common immediate Operand types (for instance i8, i32, i64, f32, f64)
are defined for all targets in <tt class="docutils literal"><span class="pre">include/llvm/Target/Target.td</span></tt>, and are
available in each Target&#8217;s OpTypes enum.  Also, only named Operand types appear
in the enumeration: anonymous types are ignored.
For example, the X86 backend defines <tt class="docutils literal"><span class="pre">brtarget</span></tt> and <tt class="docutils literal"><span class="pre">brtarget8</span></tt>, both
instances of the TableGen <tt class="docutils literal"><span class="pre">Operand</span></tt> class, which represent branch target
operands:</p>
<div class="highlight-llvm"><pre>def brtarget : Operand&lt;OtherVT&gt;;
def brtarget8 : Operand&lt;OtherVT&gt;;</pre>
</div>
<p>This results in:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">namespace</span> <span class="n">X86</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">OpTypes</span> <span class="p">{</span>
<span class="k">enum</span> <span class="n">OperandType</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">brtarget</span><span class="p">,</span>
  <span class="n">brtarget8</span><span class="p">,</span>
  <span class="p">...</span>
  <span class="n">i32imm</span><span class="p">,</span>
  <span class="n">i64imm</span><span class="p">,</span>
  <span class="p">...</span>
  <span class="n">OPERAND_TYPE_LIST_END</span>
<span class="p">}</span> <span class="c1">// End namespace OpTypes</span>
<span class="p">}</span> <span class="c1">// End namespace X86</span>
</pre></div>
</div>
<p>In typical TableGen fashion, to use the enum, you will need to define a
preprocessor macro:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#define GET_INSTRINFO_OPERAND_TYPES_ENUM </span><span class="c1">// For OpTypes enum</span>
<span class="cp">#include &quot;XXXGenInstrInfo.inc&quot;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="instruction-scheduling">
<h3><a class="toc-backref" href="#id18">Instruction Scheduling</a><a class="headerlink" href="#instruction-scheduling" title="Permalink to this headline">¶</a></h3>
<p>Instruction itineraries can be queried using MCDesc::getSchedClass(). The
value can be named by an enumemation in llvm::XXX::Sched namespace generated
by TableGen in XXXGenInstrInfo.inc. The name of the schedule classes are
the same as provided in XXXSchedule.td plus a default NoItinerary class.</p>
</div>
<div class="section" id="instruction-relation-mapping">
<h3><a class="toc-backref" href="#id19">Instruction Relation Mapping</a><a class="headerlink" href="#instruction-relation-mapping" title="Permalink to this headline">¶</a></h3>
<p>This TableGen feature is used to relate instructions with each other.  It is
particularly useful when you have multiple instruction formats and need to
switch between them after instruction selection.  This entire feature is driven
by relation models which can be defined in <tt class="docutils literal"><span class="pre">XXXInstrInfo.td</span></tt> files
according to the target-specific instruction set.  Relation models are defined
using <tt class="docutils literal"><span class="pre">InstrMapping</span></tt> class as a base.  TableGen parses all the models
and generates instruction relation maps using the specified information.
Relation maps are emitted as tables in the <tt class="docutils literal"><span class="pre">XXXGenInstrInfo.inc</span></tt> file
along with the functions to query them.  For the detailed information on how to
use this feature, please refer to <a class="reference internal" href="HowToUseInstrMappings.html"><em>How To Use Instruction Mappings</em></a>.</p>
</div>
<div class="section" id="implement-a-subclass-of-targetinstrinfo">
<h3><a class="toc-backref" href="#id20">Implement a subclass of <tt class="docutils literal"><span class="pre">TargetInstrInfo</span></tt></a><a class="headerlink" href="#implement-a-subclass-of-targetinstrinfo" title="Permalink to this headline">¶</a></h3>
<p>The final step is to hand code portions of <tt class="docutils literal"><span class="pre">XXXInstrInfo</span></tt>, which implements
the interface described in <tt class="docutils literal"><span class="pre">TargetInstrInfo.h</span></tt> (see <a class="reference internal" href="CodeGenerator.html#targetinstrinfo"><em>The TargetInstrInfo class</em></a>).
These functions return <tt class="docutils literal"><span class="pre">0</span></tt> or a Boolean or they assert, unless overridden.
Here&#8217;s a list of functions that are overridden for the SPARC implementation in
<tt class="docutils literal"><span class="pre">SparcInstrInfo.cpp</span></tt>:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">isLoadFromStackSlot</span></tt> &#8212; If the specified machine instruction is a direct
load from a stack slot, return the register number of the destination and the
<tt class="docutils literal"><span class="pre">FrameIndex</span></tt> of the stack slot.</li>
<li><tt class="docutils literal"><span class="pre">isStoreToStackSlot</span></tt> &#8212; If the specified machine instruction is a direct
store to a stack slot, return the register number of the destination and the
<tt class="docutils literal"><span class="pre">FrameIndex</span></tt> of the stack slot.</li>
<li><tt class="docutils literal"><span class="pre">copyPhysReg</span></tt> &#8212; Copy values between a pair of physical registers.</li>
<li><tt class="docutils literal"><span class="pre">storeRegToStackSlot</span></tt> &#8212; Store a register value to a stack slot.</li>
<li><tt class="docutils literal"><span class="pre">loadRegFromStackSlot</span></tt> &#8212; Load a register value from a stack slot.</li>
<li><tt class="docutils literal"><span class="pre">storeRegToAddr</span></tt> &#8212; Store a register value to memory.</li>
<li><tt class="docutils literal"><span class="pre">loadRegFromAddr</span></tt> &#8212; Load a register value from memory.</li>
<li><tt class="docutils literal"><span class="pre">foldMemoryOperand</span></tt> &#8212; Attempt to combine instructions of any load or
store instruction for the specified operand(s).</li>
</ul>
</div>
<div class="section" id="branch-folding-and-if-conversion">
<h3><a class="toc-backref" href="#id21">Branch Folding and If Conversion</a><a class="headerlink" href="#branch-folding-and-if-conversion" title="Permalink to this headline">¶</a></h3>
<p>Performance can be improved by combining instructions or by eliminating
instructions that are never reached.  The <tt class="docutils literal"><span class="pre">AnalyzeBranch</span></tt> method in
<tt class="docutils literal"><span class="pre">XXXInstrInfo</span></tt> may be implemented to examine conditional instructions and
remove unnecessary instructions.  <tt class="docutils literal"><span class="pre">AnalyzeBranch</span></tt> looks at the end of a
machine basic block (MBB) for opportunities for improvement, such as branch
folding and if conversion.  The <tt class="docutils literal"><span class="pre">BranchFolder</span></tt> and <tt class="docutils literal"><span class="pre">IfConverter</span></tt> machine
function passes (see the source files <tt class="docutils literal"><span class="pre">BranchFolding.cpp</span></tt> and
<tt class="docutils literal"><span class="pre">IfConversion.cpp</span></tt> in the <tt class="docutils literal"><span class="pre">lib/CodeGen</span></tt> directory) call <tt class="docutils literal"><span class="pre">AnalyzeBranch</span></tt>
to improve the control flow graph that represents the instructions.</p>
<p>Several implementations of <tt class="docutils literal"><span class="pre">AnalyzeBranch</span></tt> (for ARM, Alpha, and X86) can be
examined as models for your own <tt class="docutils literal"><span class="pre">AnalyzeBranch</span></tt> implementation.  Since SPARC
does not implement a useful <tt class="docutils literal"><span class="pre">AnalyzeBranch</span></tt>, the ARM target implementation is
shown below.</p>
<p><tt class="docutils literal"><span class="pre">AnalyzeBranch</span></tt> returns a Boolean value and takes four parameters:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">MachineBasicBlock</span> <span class="pre">&amp;MBB</span></tt> &#8212; The incoming block to be examined.</li>
<li><tt class="docutils literal"><span class="pre">MachineBasicBlock</span> <span class="pre">*&amp;TBB</span></tt> &#8212; A destination block that is returned.  For a
conditional branch that evaluates to true, <tt class="docutils literal"><span class="pre">TBB</span></tt> is the destination.</li>
<li><tt class="docutils literal"><span class="pre">MachineBasicBlock</span> <span class="pre">*&amp;FBB</span></tt> &#8212; For a conditional branch that evaluates to
false, <tt class="docutils literal"><span class="pre">FBB</span></tt> is returned as the destination.</li>
<li><tt class="docutils literal"><span class="pre">std::vector&lt;MachineOperand&gt;</span> <span class="pre">&amp;Cond</span></tt> &#8212; List of operands to evaluate a
condition for a conditional branch.</li>
</ul>
<p>In the simplest case, if a block ends without a branch, then it falls through
to the successor block.  No destination blocks are specified for either <tt class="docutils literal"><span class="pre">TBB</span></tt>
or <tt class="docutils literal"><span class="pre">FBB</span></tt>, so both parameters return <tt class="docutils literal"><span class="pre">NULL</span></tt>.  The start of the
<tt class="docutils literal"><span class="pre">AnalyzeBranch</span></tt> (see code below for the ARM target) shows the function
parameters and the code for the simplest case.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">ARMInstrInfo</span><span class="o">::</span><span class="n">AnalyzeBranch</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                                 <span class="n">MachineBasicBlock</span> <span class="o">*&amp;</span><span class="n">TBB</span><span class="p">,</span>
                                 <span class="n">MachineBasicBlock</span> <span class="o">*&amp;</span><span class="n">FBB</span><span class="p">,</span>
                                 <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MachineOperand</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Cond</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">I</span> <span class="o">==</span> <span class="n">MBB</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">isUnpredicatedTerminator</span><span class="p">(</span><span class="o">--</span><span class="n">I</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</pre></div>
</div>
<p>If a block ends with a single unconditional branch instruction, then
<tt class="docutils literal"><span class="pre">AnalyzeBranch</span></tt> (shown below) should return the destination of that branch in
the <tt class="docutils literal"><span class="pre">TBB</span></tt> parameter.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">LastOpc</span> <span class="o">==</span> <span class="n">ARM</span><span class="o">::</span><span class="n">B</span> <span class="o">||</span> <span class="n">LastOpc</span> <span class="o">==</span> <span class="n">ARM</span><span class="o">::</span><span class="n">tB</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">TBB</span> <span class="o">=</span> <span class="n">LastInst</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getMBB</span><span class="p">();</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If a block ends with two unconditional branches, then the second branch is
never reached.  In that situation, as shown below, remove the last branch
instruction and return the penultimate branch in the <tt class="docutils literal"><span class="pre">TBB</span></tt> parameter.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">if</span> <span class="p">((</span><span class="n">SecondLastOpc</span> <span class="o">==</span> <span class="n">ARM</span><span class="o">::</span><span class="n">B</span> <span class="o">||</span> <span class="n">SecondLastOpc</span> <span class="o">==</span> <span class="n">ARM</span><span class="o">::</span><span class="n">tB</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="p">(</span><span class="n">LastOpc</span> <span class="o">==</span> <span class="n">ARM</span><span class="o">::</span><span class="n">B</span> <span class="o">||</span> <span class="n">LastOpc</span> <span class="o">==</span> <span class="n">ARM</span><span class="o">::</span><span class="n">tB</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">TBB</span> <span class="o">=</span> <span class="n">SecondLastInst</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getMBB</span><span class="p">();</span>
  <span class="n">I</span> <span class="o">=</span> <span class="n">LastInst</span><span class="p">;</span>
  <span class="n">I</span><span class="o">-&gt;</span><span class="n">eraseFromParent</span><span class="p">();</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A block may end with a single conditional branch instruction that falls through
to successor block if the condition evaluates to false.  In that case,
<tt class="docutils literal"><span class="pre">AnalyzeBranch</span></tt> (shown below) should return the destination of that
conditional branch in the <tt class="docutils literal"><span class="pre">TBB</span></tt> parameter and a list of operands in the
<tt class="docutils literal"><span class="pre">Cond</span></tt> parameter to evaluate the condition.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">LastOpc</span> <span class="o">==</span> <span class="n">ARM</span><span class="o">::</span><span class="n">Bcc</span> <span class="o">||</span> <span class="n">LastOpc</span> <span class="o">==</span> <span class="n">ARM</span><span class="o">::</span><span class="n">tBcc</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Block ends with fall-through condbranch.</span>
  <span class="n">TBB</span> <span class="o">=</span> <span class="n">LastInst</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getMBB</span><span class="p">();</span>
  <span class="n">Cond</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">LastInst</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">Cond</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">LastInst</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If a block ends with both a conditional branch and an ensuing unconditional
branch, then <tt class="docutils literal"><span class="pre">AnalyzeBranch</span></tt> (shown below) should return the conditional
branch destination (assuming it corresponds to a conditional evaluation of
&#8220;<tt class="docutils literal"><span class="pre">true</span></tt>&#8221;) in the <tt class="docutils literal"><span class="pre">TBB</span></tt> parameter and the unconditional branch destination
in the <tt class="docutils literal"><span class="pre">FBB</span></tt> (corresponding to a conditional evaluation of &#8220;<tt class="docutils literal"><span class="pre">false</span></tt>&#8221;).  A
list of operands to evaluate the condition should be returned in the <tt class="docutils literal"><span class="pre">Cond</span></tt>
parameter.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">unsigned</span> <span class="n">SecondLastOpc</span> <span class="o">=</span> <span class="n">SecondLastInst</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">();</span>

<span class="k">if</span> <span class="p">((</span><span class="n">SecondLastOpc</span> <span class="o">==</span> <span class="n">ARM</span><span class="o">::</span><span class="n">Bcc</span> <span class="o">&amp;&amp;</span> <span class="n">LastOpc</span> <span class="o">==</span> <span class="n">ARM</span><span class="o">::</span><span class="n">B</span><span class="p">)</span> <span class="o">||</span>
    <span class="p">(</span><span class="n">SecondLastOpc</span> <span class="o">==</span> <span class="n">ARM</span><span class="o">::</span><span class="n">tBcc</span> <span class="o">&amp;&amp;</span> <span class="n">LastOpc</span> <span class="o">==</span> <span class="n">ARM</span><span class="o">::</span><span class="n">tB</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">TBB</span> <span class="o">=</span>  <span class="n">SecondLastInst</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getMBB</span><span class="p">();</span>
  <span class="n">Cond</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">SecondLastInst</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">Cond</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">SecondLastInst</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
  <span class="n">FBB</span> <span class="o">=</span> <span class="n">LastInst</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getMBB</span><span class="p">();</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For the last two cases (ending with a single conditional branch or ending with
one conditional and one unconditional branch), the operands returned in the
<tt class="docutils literal"><span class="pre">Cond</span></tt> parameter can be passed to methods of other instructions to create new
branches or perform other operations.  An implementation of <tt class="docutils literal"><span class="pre">AnalyzeBranch</span></tt>
requires the helper methods <tt class="docutils literal"><span class="pre">RemoveBranch</span></tt> and <tt class="docutils literal"><span class="pre">InsertBranch</span></tt> to manage
subsequent operations.</p>
<p><tt class="docutils literal"><span class="pre">AnalyzeBranch</span></tt> should return false indicating success in most circumstances.
<tt class="docutils literal"><span class="pre">AnalyzeBranch</span></tt> should only return true when the method is stumped about what
to do, for example, if a block has three terminating branches.
<tt class="docutils literal"><span class="pre">AnalyzeBranch</span></tt> may return true if it encounters a terminator it cannot
handle, such as an indirect branch.</p>
</div>
</div>
<div class="section" id="instruction-selector">
<span id="id2"></span><h2><a class="toc-backref" href="#id22">Instruction Selector</a><a class="headerlink" href="#instruction-selector" title="Permalink to this headline">¶</a></h2>
<p>LLVM uses a <tt class="docutils literal"><span class="pre">SelectionDAG</span></tt> to represent LLVM IR instructions, and nodes of
the <tt class="docutils literal"><span class="pre">SelectionDAG</span></tt> ideally represent native target instructions.  During code
generation, instruction selection passes are performed to convert non-native
DAG instructions into native target-specific instructions.  The pass described
in <tt class="docutils literal"><span class="pre">XXXISelDAGToDAG.cpp</span></tt> is used to match patterns and perform DAG-to-DAG
instruction selection.  Optionally, a pass may be defined (in
<tt class="docutils literal"><span class="pre">XXXBranchSelector.cpp</span></tt>) to perform similar DAG-to-DAG operations for branch
instructions.  Later, the code in <tt class="docutils literal"><span class="pre">XXXISelLowering.cpp</span></tt> replaces or removes
operations and data types not supported natively (legalizes) in a
<tt class="docutils literal"><span class="pre">SelectionDAG</span></tt>.</p>
<p>TableGen generates code for instruction selection using the following target
description input files:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">XXXInstrInfo.td</span></tt> &#8212; Contains definitions of instructions in a
target-specific instruction set, generates <tt class="docutils literal"><span class="pre">XXXGenDAGISel.inc</span></tt>, which is
included in <tt class="docutils literal"><span class="pre">XXXISelDAGToDAG.cpp</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">XXXCallingConv.td</span></tt> &#8212; Contains the calling and return value conventions
for the target architecture, and it generates <tt class="docutils literal"><span class="pre">XXXGenCallingConv.inc</span></tt>,
which is included in <tt class="docutils literal"><span class="pre">XXXISelLowering.cpp</span></tt>.</li>
</ul>
<p>The implementation of an instruction selection pass must include a header that
declares the <tt class="docutils literal"><span class="pre">FunctionPass</span></tt> class or a subclass of <tt class="docutils literal"><span class="pre">FunctionPass</span></tt>.  In
<tt class="docutils literal"><span class="pre">XXXTargetMachine.cpp</span></tt>, a Pass Manager (PM) should add each instruction
selection pass into the queue of passes to run.</p>
<p>The LLVM static compiler (<tt class="docutils literal"><span class="pre">llc</span></tt>) is an excellent tool for visualizing the
contents of DAGs.  To display the <tt class="docutils literal"><span class="pre">SelectionDAG</span></tt> before or after specific
processing phases, use the command line options for <tt class="docutils literal"><span class="pre">llc</span></tt>, described at
<a class="reference internal" href="CodeGenerator.html#selectiondag-process"><em>SelectionDAG Instruction Selection Process</em></a>.</p>
<p>To describe instruction selector behavior, you should add patterns for lowering
LLVM code into a <tt class="docutils literal"><span class="pre">SelectionDAG</span></tt> as the last parameter of the instruction
definitions in <tt class="docutils literal"><span class="pre">XXXInstrInfo.td</span></tt>.  For example, in <tt class="docutils literal"><span class="pre">SparcInstrInfo.td</span></tt>,
this entry defines a register store operation, and the last parameter describes
a pattern with the store DAG operator.</p>
<div class="highlight-llvm"><pre>def STrr  : F3_1&lt; 3, 0b000100, (outs), (ins MEMrr:$addr, IntRegs:$src),
                 "st $src, [$addr]", [(store i32:$src, ADDRrr:$addr)]&gt;;</pre>
</div>
<p><tt class="docutils literal"><span class="pre">ADDRrr</span></tt> is a memory mode that is also defined in <tt class="docutils literal"><span class="pre">SparcInstrInfo.td</span></tt>:</p>
<div class="highlight-llvm"><pre>def ADDRrr : ComplexPattern&lt;i32, 2, "SelectADDRrr", [], []&gt;;</pre>
</div>
<p>The definition of <tt class="docutils literal"><span class="pre">ADDRrr</span></tt> refers to <tt class="docutils literal"><span class="pre">SelectADDRrr</span></tt>, which is a function
defined in an implementation of the Instructor Selector (such as
<tt class="docutils literal"><span class="pre">SparcISelDAGToDAG.cpp</span></tt>).</p>
<p>In <tt class="docutils literal"><span class="pre">lib/Target/TargetSelectionDAG.td</span></tt>, the DAG operator for store is defined
below:</p>
<div class="highlight-llvm"><pre>def store : PatFrag&lt;(ops node:$val, node:$ptr),
                    (st node:$val, node:$ptr), [{
  if (StoreSDNode *ST = dyn_cast&lt;StoreSDNode&gt;(N))
    return !ST-&gt;isTruncatingStore() &amp;&amp;
           ST-&gt;getAddressingMode() == ISD::UNINDEXED;
  return false;
}]&gt;;</pre>
</div>
<p><tt class="docutils literal"><span class="pre">XXXInstrInfo.td</span></tt> also generates (in <tt class="docutils literal"><span class="pre">XXXGenDAGISel.inc</span></tt>) the
<tt class="docutils literal"><span class="pre">SelectCode</span></tt> method that is used to call the appropriate processing method
for an instruction.  In this example, <tt class="docutils literal"><span class="pre">SelectCode</span></tt> calls <tt class="docutils literal"><span class="pre">Select_ISD_STORE</span></tt>
for the <tt class="docutils literal"><span class="pre">ISD::STORE</span></tt> opcode.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SDNode</span> <span class="o">*</span><span class="nf">SelectCode</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">MVT</span><span class="o">::</span><span class="n">ValueType</span> <span class="n">NVT</span> <span class="o">=</span> <span class="n">N</span><span class="p">.</span><span class="n">getNode</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getValueType</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">N</span><span class="p">.</span><span class="n">getOpcode</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">ISD</span>:<span class="o">:</span><span class="n">STORE</span><span class="o">:</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">NVT</span><span class="p">)</span> <span class="p">{</span>
    <span class="nl">default:</span>
      <span class="k">return</span> <span class="n">Select_ISD_STORE</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="p">...</span>
</pre></div>
</div>
<p>The pattern for <tt class="docutils literal"><span class="pre">STrr</span></tt> is matched, so elsewhere in <tt class="docutils literal"><span class="pre">XXXGenDAGISel.inc</span></tt>,
code for <tt class="docutils literal"><span class="pre">STrr</span></tt> is created for <tt class="docutils literal"><span class="pre">Select_ISD_STORE</span></tt>.  The <tt class="docutils literal"><span class="pre">Emit_22</span></tt> method
is also generated in <tt class="docutils literal"><span class="pre">XXXGenDAGISel.inc</span></tt> to complete the processing of this
instruction.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SDNode</span> <span class="o">*</span><span class="nf">Select_ISD_STORE</span><span class="p">(</span><span class="k">const</span> <span class="n">SDValue</span> <span class="o">&amp;</span><span class="n">N</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">SDValue</span> <span class="n">Chain</span> <span class="o">=</span> <span class="n">N</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Predicate_store</span><span class="p">(</span><span class="n">N</span><span class="p">.</span><span class="n">getNode</span><span class="p">()))</span> <span class="p">{</span>
    <span class="n">SDValue</span> <span class="n">N1</span> <span class="o">=</span> <span class="n">N</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">N2</span> <span class="o">=</span> <span class="n">N</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">CPTmp0</span><span class="p">;</span>
    <span class="n">SDValue</span> <span class="n">CPTmp1</span><span class="p">;</span>

    <span class="c1">// Pattern: (st:void i32:i32:$src,</span>
    <span class="c1">//           ADDRrr:i32:$addr)&lt;&lt;P:Predicate_store&gt;&gt;</span>
    <span class="c1">// Emits: (STrr:void ADDRrr:i32:$addr, IntRegs:i32:$src)</span>
    <span class="c1">// Pattern complexity = 13  cost = 1  size = 0</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">SelectADDRrr</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N2</span><span class="p">,</span> <span class="n">CPTmp0</span><span class="p">,</span> <span class="n">CPTmp1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="n">N1</span><span class="p">.</span><span class="n">getNode</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getValueType</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span> <span class="o">&amp;&amp;</span>
        <span class="n">N2</span><span class="p">.</span><span class="n">getNode</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getValueType</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">Emit_22</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">STrr</span><span class="p">,</span> <span class="n">CPTmp0</span><span class="p">,</span> <span class="n">CPTmp1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<div class="section" id="the-selectiondag-legalize-phase">
<h3><a class="toc-backref" href="#id23">The SelectionDAG Legalize Phase</a><a class="headerlink" href="#the-selectiondag-legalize-phase" title="Permalink to this headline">¶</a></h3>
<p>The Legalize phase converts a DAG to use types and operations that are natively
supported by the target.  For natively unsupported types and operations, you
need to add code to the target-specific <tt class="docutils literal"><span class="pre">XXXTargetLowering</span></tt> implementation to
convert unsupported types and operations to supported ones.</p>
<p>In the constructor for the <tt class="docutils literal"><span class="pre">XXXTargetLowering</span></tt> class, first use the
<tt class="docutils literal"><span class="pre">addRegisterClass</span></tt> method to specify which types are supported and which
register classes are associated with them.  The code for the register classes
are generated by TableGen from <tt class="docutils literal"><span class="pre">XXXRegisterInfo.td</span></tt> and placed in
<tt class="docutils literal"><span class="pre">XXXGenRegisterInfo.h.inc</span></tt>.  For example, the implementation of the
constructor for the SparcTargetLowering class (in <tt class="docutils literal"><span class="pre">SparcISelLowering.cpp</span></tt>)
starts with the following code:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">addRegisterClass</span><span class="p">(</span><span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">IntRegsRegisterClass</span><span class="p">);</span>
<span class="n">addRegisterClass</span><span class="p">(</span><span class="n">MVT</span><span class="o">::</span><span class="n">f32</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">FPRegsRegisterClass</span><span class="p">);</span>
<span class="n">addRegisterClass</span><span class="p">(</span><span class="n">MVT</span><span class="o">::</span><span class="n">f64</span><span class="p">,</span> <span class="n">SP</span><span class="o">::</span><span class="n">DFPRegsRegisterClass</span><span class="p">);</span>
</pre></div>
</div>
<p>You should examine the node types in the <tt class="docutils literal"><span class="pre">ISD</span></tt> namespace
(<tt class="docutils literal"><span class="pre">include/llvm/CodeGen/SelectionDAGNodes.h</span></tt>) and determine which operations
the target natively supports.  For operations that do <strong>not</strong> have native
support, add a callback to the constructor for the <tt class="docutils literal"><span class="pre">XXXTargetLowering</span></tt> class,
so the instruction selection process knows what to do.  The <tt class="docutils literal"><span class="pre">TargetLowering</span></tt>
class callback methods (declared in <tt class="docutils literal"><span class="pre">llvm/Target/TargetLowering.h</span></tt>) are:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">setOperationAction</span></tt> &#8212; General operation.</li>
<li><tt class="docutils literal"><span class="pre">setLoadExtAction</span></tt> &#8212; Load with extension.</li>
<li><tt class="docutils literal"><span class="pre">setTruncStoreAction</span></tt> &#8212; Truncating store.</li>
<li><tt class="docutils literal"><span class="pre">setIndexedLoadAction</span></tt> &#8212; Indexed load.</li>
<li><tt class="docutils literal"><span class="pre">setIndexedStoreAction</span></tt> &#8212; Indexed store.</li>
<li><tt class="docutils literal"><span class="pre">setConvertAction</span></tt> &#8212; Type conversion.</li>
<li><tt class="docutils literal"><span class="pre">setCondCodeAction</span></tt> &#8212; Support for a given condition code.</li>
</ul>
<p>Note: on older releases, <tt class="docutils literal"><span class="pre">setLoadXAction</span></tt> is used instead of
<tt class="docutils literal"><span class="pre">setLoadExtAction</span></tt>.  Also, on older releases, <tt class="docutils literal"><span class="pre">setCondCodeAction</span></tt> may not
be supported.  Examine your release to see what methods are specifically
supported.</p>
<p>These callbacks are used to determine that an operation does or does not work
with a specified type (or types).  And in all cases, the third parameter is a
<tt class="docutils literal"><span class="pre">LegalAction</span></tt> type enum value: <tt class="docutils literal"><span class="pre">Promote</span></tt>, <tt class="docutils literal"><span class="pre">Expand</span></tt>, <tt class="docutils literal"><span class="pre">Custom</span></tt>, or
<tt class="docutils literal"><span class="pre">Legal</span></tt>.  <tt class="docutils literal"><span class="pre">SparcISelLowering.cpp</span></tt> contains examples of all four
<tt class="docutils literal"><span class="pre">LegalAction</span></tt> values.</p>
<div class="section" id="promote">
<h4><a class="toc-backref" href="#id24">Promote</a><a class="headerlink" href="#promote" title="Permalink to this headline">¶</a></h4>
<p>For an operation without native support for a given type, the specified type
may be promoted to a larger type that is supported.  For example, SPARC does
not support a sign-extending load for Boolean values (<tt class="docutils literal"><span class="pre">i1</span></tt> type), so in
<tt class="docutils literal"><span class="pre">SparcISelLowering.cpp</span></tt> the third parameter below, <tt class="docutils literal"><span class="pre">Promote</span></tt>, changes
<tt class="docutils literal"><span class="pre">i1</span></tt> type values to a large type before loading.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">setLoadExtAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">SEXTLOAD</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i1</span><span class="p">,</span> <span class="n">Promote</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="expand">
<h4><a class="toc-backref" href="#id25">Expand</a><a class="headerlink" href="#expand" title="Permalink to this headline">¶</a></h4>
<p>For a type without native support, a value may need to be broken down further,
rather than promoted.  For an operation without native support, a combination
of other operations may be used to similar effect.  In SPARC, the
floating-point sine and cosine trig operations are supported by expansion to
other operations, as indicated by the third parameter, <tt class="docutils literal"><span class="pre">Expand</span></tt>, to
<tt class="docutils literal"><span class="pre">setOperationAction</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">FSIN</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">f32</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
<span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">FCOS</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">f32</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="custom">
<h4><a class="toc-backref" href="#id26">Custom</a><a class="headerlink" href="#custom" title="Permalink to this headline">¶</a></h4>
<p>For some operations, simple type promotion or operation expansion may be
insufficient.  In some cases, a special intrinsic function must be implemented.</p>
<p>For example, a constant value may require special treatment, or an operation
may require spilling and restoring registers in the stack and working with
register allocators.</p>
<p>As seen in <tt class="docutils literal"><span class="pre">SparcISelLowering.cpp</span></tt> code below, to perform a type conversion
from a floating point value to a signed integer, first the
<tt class="docutils literal"><span class="pre">setOperationAction</span></tt> should be called with <tt class="docutils literal"><span class="pre">Custom</span></tt> as the third parameter:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">FP_TO_SINT</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">Custom</span><span class="p">);</span>
</pre></div>
</div>
<p>In the <tt class="docutils literal"><span class="pre">LowerOperation</span></tt> method, for each <tt class="docutils literal"><span class="pre">Custom</span></tt> operation, a case
statement should be added to indicate what function to call.  In the following
code, an <tt class="docutils literal"><span class="pre">FP_TO_SINT</span></tt> opcode will call the <tt class="docutils literal"><span class="pre">LowerFP_TO_SINT</span></tt> method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SDValue</span> <span class="n">SparcTargetLowering</span><span class="o">::</span><span class="n">LowerOperation</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">getOpcode</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">ISD</span>:<span class="o">:</span><span class="n">FP_TO_SINT</span><span class="o">:</span> <span class="k">return</span> <span class="n">LowerFP_TO_SINT</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
  <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, the <tt class="docutils literal"><span class="pre">LowerFP_TO_SINT</span></tt> method is implemented, using an FP register to
convert the floating-point value to an integer.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="n">SDValue</span> <span class="nf">LowerFP_TO_SINT</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">getValueType</span><span class="p">()</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">);</span>
  <span class="n">Op</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">SPISD</span><span class="o">::</span><span class="n">FTOI</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">f32</span><span class="p">,</span> <span class="n">Op</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">BITCAST</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">Op</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="legal">
<h4><a class="toc-backref" href="#id27">Legal</a><a class="headerlink" href="#legal" title="Permalink to this headline">¶</a></h4>
<p>The <tt class="docutils literal"><span class="pre">Legal</span></tt> <tt class="docutils literal"><span class="pre">LegalizeAction</span></tt> enum value simply indicates that an operation
<strong>is</strong> natively supported.  <tt class="docutils literal"><span class="pre">Legal</span></tt> represents the default condition, so it
is rarely used.  In <tt class="docutils literal"><span class="pre">SparcISelLowering.cpp</span></tt>, the action for <tt class="docutils literal"><span class="pre">CTPOP</span></tt> (an
operation to count the bits set in an integer) is natively supported only for
SPARC v9.  The following code enables the <tt class="docutils literal"><span class="pre">Expand</span></tt> conversion technique for
non-v9 SPARC implementations.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">CTPOP</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
<span class="p">...</span>
<span class="k">if</span> <span class="p">(</span><span class="n">TM</span><span class="p">.</span><span class="n">getSubtarget</span><span class="o">&lt;</span><span class="n">SparcSubtarget</span><span class="o">&gt;</span><span class="p">().</span><span class="n">isV9</span><span class="p">())</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">CTPOP</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">Legal</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="calling-conventions">
<h3><a class="toc-backref" href="#id28">Calling Conventions</a><a class="headerlink" href="#calling-conventions" title="Permalink to this headline">¶</a></h3>
<p>To support target-specific calling conventions, <tt class="docutils literal"><span class="pre">XXXGenCallingConv.td</span></tt> uses
interfaces (such as <tt class="docutils literal"><span class="pre">CCIfType</span></tt> and <tt class="docutils literal"><span class="pre">CCAssignToReg</span></tt>) that are defined in
<tt class="docutils literal"><span class="pre">lib/Target/TargetCallingConv.td</span></tt>.  TableGen can take the target descriptor
file <tt class="docutils literal"><span class="pre">XXXGenCallingConv.td</span></tt> and generate the header file
<tt class="docutils literal"><span class="pre">XXXGenCallingConv.inc</span></tt>, which is typically included in
<tt class="docutils literal"><span class="pre">XXXISelLowering.cpp</span></tt>.  You can use the interfaces in
<tt class="docutils literal"><span class="pre">TargetCallingConv.td</span></tt> to specify:</p>
<ul class="simple">
<li>The order of parameter allocation.</li>
<li>Where parameters and return values are placed (that is, on the stack or in
registers).</li>
<li>Which registers may be used.</li>
<li>Whether the caller or callee unwinds the stack.</li>
</ul>
<p>The following example demonstrates the use of the <tt class="docutils literal"><span class="pre">CCIfType</span></tt> and
<tt class="docutils literal"><span class="pre">CCAssignToReg</span></tt> interfaces.  If the <tt class="docutils literal"><span class="pre">CCIfType</span></tt> predicate is true (that is,
if the current argument is of type <tt class="docutils literal"><span class="pre">f32</span></tt> or <tt class="docutils literal"><span class="pre">f64</span></tt>), then the action is
performed.  In this case, the <tt class="docutils literal"><span class="pre">CCAssignToReg</span></tt> action assigns the argument
value to the first available register: either <tt class="docutils literal"><span class="pre">R0</span></tt> or <tt class="docutils literal"><span class="pre">R1</span></tt>.</p>
<div class="highlight-llvm"><pre>CCIfType&lt;[f32,f64], CCAssignToReg&lt;[R0, R1]&gt;&gt;</pre>
</div>
<p><tt class="docutils literal"><span class="pre">SparcCallingConv.td</span></tt> contains definitions for a target-specific return-value
calling convention (<tt class="docutils literal"><span class="pre">RetCC_Sparc32</span></tt>) and a basic 32-bit C calling convention
(<tt class="docutils literal"><span class="pre">CC_Sparc32</span></tt>).  The definition of <tt class="docutils literal"><span class="pre">RetCC_Sparc32</span></tt> (shown below) indicates
which registers are used for specified scalar return types.  A single-precision
float is returned to register <tt class="docutils literal"><span class="pre">F0</span></tt>, and a double-precision float goes to
register <tt class="docutils literal"><span class="pre">D0</span></tt>.  A 32-bit integer is returned in register <tt class="docutils literal"><span class="pre">I0</span></tt> or <tt class="docutils literal"><span class="pre">I1</span></tt>.</p>
<div class="highlight-llvm"><pre>def RetCC_Sparc32 : CallingConv&lt;[
  CCIfType&lt;[i32], CCAssignToReg&lt;[I0, I1]&gt;&gt;,
  CCIfType&lt;[f32], CCAssignToReg&lt;[F0]&gt;&gt;,
  CCIfType&lt;[f64], CCAssignToReg&lt;[D0]&gt;&gt;
]&gt;;</pre>
</div>
<p>The definition of <tt class="docutils literal"><span class="pre">CC_Sparc32</span></tt> in <tt class="docutils literal"><span class="pre">SparcCallingConv.td</span></tt> introduces
<tt class="docutils literal"><span class="pre">CCAssignToStack</span></tt>, which assigns the value to a stack slot with the specified
size and alignment.  In the example below, the first parameter, 4, indicates
the size of the slot, and the second parameter, also 4, indicates the stack
alignment along 4-byte units.  (Special cases: if size is zero, then the ABI
size is used; if alignment is zero, then the ABI alignment is used.)</p>
<div class="highlight-llvm"><pre>def CC_Sparc32 : CallingConv&lt;[
  // All arguments get passed in integer registers if there is space.
  CCIfType&lt;[i32, f32, f64], CCAssignToReg&lt;[I0, I1, I2, I3, I4, I5]&gt;&gt;,
  CCAssignToStack&lt;4, 4&gt;
]&gt;;</pre>
</div>
<p><tt class="docutils literal"><span class="pre">CCDelegateTo</span></tt> is another commonly used interface, which tries to find a
specified sub-calling convention, and, if a match is found, it is invoked.  In
the following example (in <tt class="docutils literal"><span class="pre">X86CallingConv.td</span></tt>), the definition of
<tt class="docutils literal"><span class="pre">RetCC_X86_32_C</span></tt> ends with <tt class="docutils literal"><span class="pre">CCDelegateTo</span></tt>.  After the current value is
assigned to the register <tt class="docutils literal"><span class="pre">ST0</span></tt> or <tt class="docutils literal"><span class="pre">ST1</span></tt>, the <tt class="docutils literal"><span class="pre">RetCC_X86Common</span></tt> is
invoked.</p>
<div class="highlight-llvm"><pre>def RetCC_X86_32_C : CallingConv&lt;[
  CCIfType&lt;[f32], CCAssignToReg&lt;[ST0, ST1]&gt;&gt;,
  CCIfType&lt;[f64], CCAssignToReg&lt;[ST0, ST1]&gt;&gt;,
  CCDelegateTo&lt;RetCC_X86Common&gt;
]&gt;;</pre>
</div>
<p><tt class="docutils literal"><span class="pre">CCIfCC</span></tt> is an interface that attempts to match the given name to the current
calling convention.  If the name identifies the current calling convention,
then a specified action is invoked.  In the following example (in
<tt class="docutils literal"><span class="pre">X86CallingConv.td</span></tt>), if the <tt class="docutils literal"><span class="pre">Fast</span></tt> calling convention is in use, then
<tt class="docutils literal"><span class="pre">RetCC_X86_32_Fast</span></tt> is invoked.  If the <tt class="docutils literal"><span class="pre">SSECall</span></tt> calling convention is in
use, then <tt class="docutils literal"><span class="pre">RetCC_X86_32_SSE</span></tt> is invoked.</p>
<div class="highlight-llvm"><pre>def RetCC_X86_32 : CallingConv&lt;[
  CCIfCC&lt;"CallingConv::Fast", CCDelegateTo&lt;RetCC_X86_32_Fast&gt;&gt;,
  CCIfCC&lt;"CallingConv::X86_SSECall", CCDelegateTo&lt;RetCC_X86_32_SSE&gt;&gt;,
  CCDelegateTo&lt;RetCC_X86_32_C&gt;
]&gt;;</pre>
</div>
<p>Other calling convention interfaces include:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">CCIf</span> <span class="pre">&lt;predicate,</span> <span class="pre">action&gt;</span></tt> &#8212; If the predicate matches, apply the action.</li>
<li><tt class="docutils literal"><span class="pre">CCIfInReg</span> <span class="pre">&lt;action&gt;</span></tt> &#8212; If the argument is marked with the &#8220;<tt class="docutils literal"><span class="pre">inreg</span></tt>&#8221;
attribute, then apply the action.</li>
<li><tt class="docutils literal"><span class="pre">CCIfNest</span> <span class="pre">&lt;action&gt;</span></tt> &#8212; If the argument is marked with the &#8220;<tt class="docutils literal"><span class="pre">nest</span></tt>&#8221;
attribute, then apply the action.</li>
<li><tt class="docutils literal"><span class="pre">CCIfNotVarArg</span> <span class="pre">&lt;action&gt;</span></tt> &#8212; If the current function does not take a
variable number of arguments, apply the action.</li>
<li><tt class="docutils literal"><span class="pre">CCAssignToRegWithShadow</span> <span class="pre">&lt;registerList,</span> <span class="pre">shadowList&gt;</span></tt> &#8212; similar to
<tt class="docutils literal"><span class="pre">CCAssignToReg</span></tt>, but with a shadow list of registers.</li>
<li><tt class="docutils literal"><span class="pre">CCPassByVal</span> <span class="pre">&lt;size,</span> <span class="pre">align&gt;</span></tt> &#8212; Assign value to a stack slot with the
minimum specified size and alignment.</li>
<li><tt class="docutils literal"><span class="pre">CCPromoteToType</span> <span class="pre">&lt;type&gt;</span></tt> &#8212; Promote the current value to the specified
type.</li>
<li><tt class="docutils literal"><span class="pre">CallingConv</span> <span class="pre">&lt;[actions]&gt;</span></tt> &#8212; Define each calling convention that is
supported.</li>
</ul>
</div>
</div>
<div class="section" id="assembly-printer">
<h2><a class="toc-backref" href="#id29">Assembly Printer</a><a class="headerlink" href="#assembly-printer" title="Permalink to this headline">¶</a></h2>
<p>During the code emission stage, the code generator may utilize an LLVM pass to
produce assembly output.  To do this, you want to implement the code for a
printer that converts LLVM IR to a GAS-format assembly language for your target
machine, using the following steps:</p>
<ul class="simple">
<li>Define all the assembly strings for your target, adding them to the
instructions defined in the <tt class="docutils literal"><span class="pre">XXXInstrInfo.td</span></tt> file.  (See
<a class="reference internal" href="#instruction-set"><em>Instruction Set</em></a>.)  TableGen will produce an output file
(<tt class="docutils literal"><span class="pre">XXXGenAsmWriter.inc</span></tt>) with an implementation of the <tt class="docutils literal"><span class="pre">printInstruction</span></tt>
method for the <tt class="docutils literal"><span class="pre">XXXAsmPrinter</span></tt> class.</li>
<li>Write <tt class="docutils literal"><span class="pre">XXXTargetAsmInfo.h</span></tt>, which contains the bare-bones declaration of
the <tt class="docutils literal"><span class="pre">XXXTargetAsmInfo</span></tt> class (a subclass of <tt class="docutils literal"><span class="pre">TargetAsmInfo</span></tt>).</li>
<li>Write <tt class="docutils literal"><span class="pre">XXXTargetAsmInfo.cpp</span></tt>, which contains target-specific values for
<tt class="docutils literal"><span class="pre">TargetAsmInfo</span></tt> properties and sometimes new implementations for methods.</li>
<li>Write <tt class="docutils literal"><span class="pre">XXXAsmPrinter.cpp</span></tt>, which implements the <tt class="docutils literal"><span class="pre">AsmPrinter</span></tt> class that
performs the LLVM-to-assembly conversion.</li>
</ul>
<p>The code in <tt class="docutils literal"><span class="pre">XXXTargetAsmInfo.h</span></tt> is usually a trivial declaration of the
<tt class="docutils literal"><span class="pre">XXXTargetAsmInfo</span></tt> class for use in <tt class="docutils literal"><span class="pre">XXXTargetAsmInfo.cpp</span></tt>.  Similarly,
<tt class="docutils literal"><span class="pre">XXXTargetAsmInfo.cpp</span></tt> usually has a few declarations of <tt class="docutils literal"><span class="pre">XXXTargetAsmInfo</span></tt>
replacement values that override the default values in <tt class="docutils literal"><span class="pre">TargetAsmInfo.cpp</span></tt>.
For example in <tt class="docutils literal"><span class="pre">SparcTargetAsmInfo.cpp</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SparcTargetAsmInfo</span><span class="o">::</span><span class="n">SparcTargetAsmInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">SparcTargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Data16bitsDirective</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.half</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">Data32bitsDirective</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.word</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">Data64bitsDirective</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// .xword is only supported by V9.</span>
  <span class="n">ZeroDirective</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.skip</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">CommentString</span> <span class="o">=</span> <span class="s">&quot;!&quot;</span><span class="p">;</span>
  <span class="n">ConstantPoolSection</span> <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.section </span><span class="se">\&quot;</span><span class="s">.rodata</span><span class="se">\&quot;</span><span class="s">,#alloc</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The X86 assembly printer implementation (<tt class="docutils literal"><span class="pre">X86TargetAsmInfo</span></tt>) is an example
where the target specific <tt class="docutils literal"><span class="pre">TargetAsmInfo</span></tt> class uses an overridden methods:
<tt class="docutils literal"><span class="pre">ExpandInlineAsm</span></tt>.</p>
<p>A target-specific implementation of <tt class="docutils literal"><span class="pre">AsmPrinter</span></tt> is written in
<tt class="docutils literal"><span class="pre">XXXAsmPrinter.cpp</span></tt>, which implements the <tt class="docutils literal"><span class="pre">AsmPrinter</span></tt> class that converts
the LLVM to printable assembly.  The implementation must include the following
headers that have declarations for the <tt class="docutils literal"><span class="pre">AsmPrinter</span></tt> and
<tt class="docutils literal"><span class="pre">MachineFunctionPass</span></tt> classes.  The <tt class="docutils literal"><span class="pre">MachineFunctionPass</span></tt> is a subclass of
<tt class="docutils literal"><span class="pre">FunctionPass</span></tt>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;llvm/CodeGen/AsmPrinter.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFunctionPass.h&quot;</span>
</pre></div>
</div>
<p>As a <tt class="docutils literal"><span class="pre">FunctionPass</span></tt>, <tt class="docutils literal"><span class="pre">AsmPrinter</span></tt> first calls <tt class="docutils literal"><span class="pre">doInitialization</span></tt> to set
up the <tt class="docutils literal"><span class="pre">AsmPrinter</span></tt>.  In <tt class="docutils literal"><span class="pre">SparcAsmPrinter</span></tt>, a <tt class="docutils literal"><span class="pre">Mangler</span></tt> object is
instantiated to process variable names.</p>
<p>In <tt class="docutils literal"><span class="pre">XXXAsmPrinter.cpp</span></tt>, the <tt class="docutils literal"><span class="pre">runOnMachineFunction</span></tt> method (declared in
<tt class="docutils literal"><span class="pre">MachineFunctionPass</span></tt>) must be implemented for <tt class="docutils literal"><span class="pre">XXXAsmPrinter</span></tt>.  In
<tt class="docutils literal"><span class="pre">MachineFunctionPass</span></tt>, the <tt class="docutils literal"><span class="pre">runOnFunction</span></tt> method invokes
<tt class="docutils literal"><span class="pre">runOnMachineFunction</span></tt>.  Target-specific implementations of
<tt class="docutils literal"><span class="pre">runOnMachineFunction</span></tt> differ, but generally do the following to process each
machine function:</p>
<ul class="simple">
<li>Call <tt class="docutils literal"><span class="pre">SetupMachineFunction</span></tt> to perform initialization.</li>
<li>Call <tt class="docutils literal"><span class="pre">EmitConstantPool</span></tt> to print out (to the output stream) constants which
have been spilled to memory.</li>
<li>Call <tt class="docutils literal"><span class="pre">EmitJumpTableInfo</span></tt> to print out jump tables used by the current
function.</li>
<li>Print out the label for the current function.</li>
<li>Print out the code for the function, including basic block labels and the
assembly for the instruction (using <tt class="docutils literal"><span class="pre">printInstruction</span></tt>)</li>
</ul>
<p>The <tt class="docutils literal"><span class="pre">XXXAsmPrinter</span></tt> implementation must also include the code generated by
TableGen that is output in the <tt class="docutils literal"><span class="pre">XXXGenAsmWriter.inc</span></tt> file.  The code in
<tt class="docutils literal"><span class="pre">XXXGenAsmWriter.inc</span></tt> contains an implementation of the <tt class="docutils literal"><span class="pre">printInstruction</span></tt>
method that may call these methods:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">printOperand</span></tt></li>
<li><tt class="docutils literal"><span class="pre">printMemOperand</span></tt></li>
<li><tt class="docutils literal"><span class="pre">printCCOperand</span></tt> (for conditional statements)</li>
<li><tt class="docutils literal"><span class="pre">printDataDirective</span></tt></li>
<li><tt class="docutils literal"><span class="pre">printDeclare</span></tt></li>
<li><tt class="docutils literal"><span class="pre">printImplicitDef</span></tt></li>
<li><tt class="docutils literal"><span class="pre">printInlineAsm</span></tt></li>
</ul>
<p>The implementations of <tt class="docutils literal"><span class="pre">printDeclare</span></tt>, <tt class="docutils literal"><span class="pre">printImplicitDef</span></tt>,
<tt class="docutils literal"><span class="pre">printInlineAsm</span></tt>, and <tt class="docutils literal"><span class="pre">printLabel</span></tt> in <tt class="docutils literal"><span class="pre">AsmPrinter.cpp</span></tt> are generally
adequate for printing assembly and do not need to be overridden.</p>
<p>The <tt class="docutils literal"><span class="pre">printOperand</span></tt> method is implemented with a long <tt class="docutils literal"><span class="pre">switch</span></tt>/<tt class="docutils literal"><span class="pre">case</span></tt>
statement for the type of operand: register, immediate, basic block, external
symbol, global address, constant pool index, or jump table index.  For an
instruction with a memory address operand, the <tt class="docutils literal"><span class="pre">printMemOperand</span></tt> method
should be implemented to generate the proper output.  Similarly,
<tt class="docutils literal"><span class="pre">printCCOperand</span></tt> should be used to print a conditional operand.</p>
<p><tt class="docutils literal"><span class="pre">doFinalization</span></tt> should be overridden in <tt class="docutils literal"><span class="pre">XXXAsmPrinter</span></tt>, and it should be
called to shut down the assembly printer.  During <tt class="docutils literal"><span class="pre">doFinalization</span></tt>, global
variables and constants are printed to output.</p>
</div>
<div class="section" id="subtarget-support">
<h2><a class="toc-backref" href="#id30">Subtarget Support</a><a class="headerlink" href="#subtarget-support" title="Permalink to this headline">¶</a></h2>
<p>Subtarget support is used to inform the code generation process of instruction
set variations for a given chip set.  For example, the LLVM SPARC
implementation provided covers three major versions of the SPARC microprocessor
architecture: Version 8 (V8, which is a 32-bit architecture), Version 9 (V9, a
64-bit architecture), and the UltraSPARC architecture.  V8 has 16
double-precision floating-point registers that are also usable as either 32
single-precision or 8 quad-precision registers.  V8 is also purely big-endian.
V9 has 32 double-precision floating-point registers that are also usable as 16
quad-precision registers, but cannot be used as single-precision registers.
The UltraSPARC architecture combines V9 with UltraSPARC Visual Instruction Set
extensions.</p>
<p>If subtarget support is needed, you should implement a target-specific
<tt class="docutils literal"><span class="pre">XXXSubtarget</span></tt> class for your architecture.  This class should process the
command-line options <tt class="docutils literal"><span class="pre">-mcpu=</span></tt> and <tt class="docutils literal"><span class="pre">-mattr=</span></tt>.</p>
<p>TableGen uses definitions in the <tt class="docutils literal"><span class="pre">Target.td</span></tt> and <tt class="docutils literal"><span class="pre">Sparc.td</span></tt> files to
generate code in <tt class="docutils literal"><span class="pre">SparcGenSubtarget.inc</span></tt>.  In <tt class="docutils literal"><span class="pre">Target.td</span></tt>, shown below, the
<tt class="docutils literal"><span class="pre">SubtargetFeature</span></tt> interface is defined.  The first 4 string parameters of
the <tt class="docutils literal"><span class="pre">SubtargetFeature</span></tt> interface are a feature name, an attribute set by the
feature, the value of the attribute, and a description of the feature.  (The
fifth parameter is a list of features whose presence is implied, and its
default value is an empty array.)</p>
<div class="highlight-llvm"><pre>class SubtargetFeature&lt;string n, string a, string v, string d,
                       list&lt;SubtargetFeature&gt; i = []&gt; {
  string Name = n;
  string Attribute = a;
  string Value = v;
  string Desc = d;
  list&lt;SubtargetFeature&gt; Implies = i;
}</pre>
</div>
<p>In the <tt class="docutils literal"><span class="pre">Sparc.td</span></tt> file, the <tt class="docutils literal"><span class="pre">SubtargetFeature</span></tt> is used to define the
following features.</p>
<div class="highlight-llvm"><pre>def FeatureV9 : SubtargetFeature&lt;"v9", "IsV9", "true",
                     "Enable SPARC-V9 instructions"&gt;;
def FeatureV8Deprecated : SubtargetFeature&lt;"deprecated-v8",
                     "V8DeprecatedInsts", "true",
                     "Enable deprecated V8 instructions in V9 mode"&gt;;
def FeatureVIS : SubtargetFeature&lt;"vis", "IsVIS", "true",
                     "Enable UltraSPARC Visual Instruction Set extensions"&gt;;</pre>
</div>
<p>Elsewhere in <tt class="docutils literal"><span class="pre">Sparc.td</span></tt>, the <tt class="docutils literal"><span class="pre">Proc</span></tt> class is defined and then is used to
define particular SPARC processor subtypes that may have the previously
described features.</p>
<div class="highlight-llvm"><pre>class Proc&lt;string Name, list&lt;SubtargetFeature&gt; Features&gt;
  : Processor&lt;Name, NoItineraries, Features&gt;;

def : Proc&lt;"generic",         []&gt;;
def : Proc&lt;"v8",              []&gt;;
def : Proc&lt;"supersparc",      []&gt;;
def : Proc&lt;"sparclite",       []&gt;;
def : Proc&lt;"f934",            []&gt;;
def : Proc&lt;"hypersparc",      []&gt;;
def : Proc&lt;"sparclite86x",    []&gt;;
def : Proc&lt;"sparclet",        []&gt;;
def : Proc&lt;"tsc701",          []&gt;;
def : Proc&lt;"v9",              [FeatureV9]&gt;;
def : Proc&lt;"ultrasparc",      [FeatureV9, FeatureV8Deprecated]&gt;;
def : Proc&lt;"ultrasparc3",     [FeatureV9, FeatureV8Deprecated]&gt;;
def : Proc&lt;"ultrasparc3-vis", [FeatureV9, FeatureV8Deprecated, FeatureVIS]&gt;;</pre>
</div>
<p>From <tt class="docutils literal"><span class="pre">Target.td</span></tt> and <tt class="docutils literal"><span class="pre">Sparc.td</span></tt> files, the resulting
<tt class="docutils literal"><span class="pre">SparcGenSubtarget.inc</span></tt> specifies enum values to identify the features,
arrays of constants to represent the CPU features and CPU subtypes, and the
<tt class="docutils literal"><span class="pre">ParseSubtargetFeatures</span></tt> method that parses the features string that sets
specified subtarget options.  The generated <tt class="docutils literal"><span class="pre">SparcGenSubtarget.inc</span></tt> file
should be included in the <tt class="docutils literal"><span class="pre">SparcSubtarget.cpp</span></tt>.  The target-specific
implementation of the <tt class="docutils literal"><span class="pre">XXXSubtarget</span></tt> method should follow this pseudocode:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">XXXSubtarget</span><span class="o">::</span><span class="n">XXXSubtarget</span><span class="p">(</span><span class="k">const</span> <span class="n">Module</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">FS</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Set the default features</span>
  <span class="c1">// Determine default and user specified characteristics of the CPU</span>
  <span class="c1">// Call ParseSubtargetFeatures(FS, CPU) to parse the features string</span>
  <span class="c1">// Perform any additional operations</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="jit-support">
<h2><a class="toc-backref" href="#id31">JIT Support</a><a class="headerlink" href="#jit-support" title="Permalink to this headline">¶</a></h2>
<p>The implementation of a target machine optionally includes a Just-In-Time (JIT)
code generator that emits machine code and auxiliary structures as binary
output that can be written directly to memory.  To do this, implement JIT code
generation by performing the following steps:</p>
<ul class="simple">
<li>Write an <tt class="docutils literal"><span class="pre">XXXCodeEmitter.cpp</span></tt> file that contains a machine function pass
that transforms target-machine instructions into relocatable machine
code.</li>
<li>Write an <tt class="docutils literal"><span class="pre">XXXJITInfo.cpp</span></tt> file that implements the JIT interfaces for
target-specific code-generation activities, such as emitting machine code and
stubs.</li>
<li>Modify <tt class="docutils literal"><span class="pre">XXXTargetMachine</span></tt> so that it provides a <tt class="docutils literal"><span class="pre">TargetJITInfo</span></tt> object
through its <tt class="docutils literal"><span class="pre">getJITInfo</span></tt> method.</li>
</ul>
<p>There are several different approaches to writing the JIT support code.  For
instance, TableGen and target descriptor files may be used for creating a JIT
code generator, but are not mandatory.  For the Alpha and PowerPC target
machines, TableGen is used to generate <tt class="docutils literal"><span class="pre">XXXGenCodeEmitter.inc</span></tt>, which
contains the binary coding of machine instructions and the
<tt class="docutils literal"><span class="pre">getBinaryCodeForInstr</span></tt> method to access those codes.  Other JIT
implementations do not.</p>
<p>Both <tt class="docutils literal"><span class="pre">XXXJITInfo.cpp</span></tt> and <tt class="docutils literal"><span class="pre">XXXCodeEmitter.cpp</span></tt> must include the
<tt class="docutils literal"><span class="pre">llvm/CodeGen/MachineCodeEmitter.h</span></tt> header file that defines the
<tt class="docutils literal"><span class="pre">MachineCodeEmitter</span></tt> class containing code for several callback functions
that write data (in bytes, words, strings, etc.) to the output stream.</p>
<div class="section" id="machine-code-emitter">
<h3><a class="toc-backref" href="#id32">Machine Code Emitter</a><a class="headerlink" href="#machine-code-emitter" title="Permalink to this headline">¶</a></h3>
<p>In <tt class="docutils literal"><span class="pre">XXXCodeEmitter.cpp</span></tt>, a target-specific of the <tt class="docutils literal"><span class="pre">Emitter</span></tt> class is
implemented as a function pass (subclass of <tt class="docutils literal"><span class="pre">MachineFunctionPass</span></tt>).  The
target-specific implementation of <tt class="docutils literal"><span class="pre">runOnMachineFunction</span></tt> (invoked by
<tt class="docutils literal"><span class="pre">runOnFunction</span></tt> in <tt class="docutils literal"><span class="pre">MachineFunctionPass</span></tt>) iterates through the
<tt class="docutils literal"><span class="pre">MachineBasicBlock</span></tt> calls <tt class="docutils literal"><span class="pre">emitInstruction</span></tt> to process each instruction and
emit binary code.  <tt class="docutils literal"><span class="pre">emitInstruction</span></tt> is largely implemented with case
statements on the instruction types defined in <tt class="docutils literal"><span class="pre">XXXInstrInfo.h</span></tt>.  For
example, in <tt class="docutils literal"><span class="pre">X86CodeEmitter.cpp</span></tt>, the <tt class="docutils literal"><span class="pre">emitInstruction</span></tt> method is built
around the following <tt class="docutils literal"><span class="pre">switch</span></tt>/<tt class="docutils literal"><span class="pre">case</span></tt> statements:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">switch</span> <span class="p">(</span><span class="n">Desc</span><span class="o">-&gt;</span><span class="n">TSFlags</span> <span class="o">&amp;</span> <span class="n">X86</span><span class="o">::</span><span class="n">FormMask</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">Pseudo</span><span class="o">:</span>  <span class="c1">// for not yet implemented instructions</span>
   <span class="p">...</span>               <span class="c1">// or pseudo-instructions</span>
   <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">RawFrm</span><span class="o">:</span>  <span class="c1">// for instructions with a fixed opcode value</span>
   <span class="p">...</span>
   <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">AddRegFrm</span><span class="o">:</span> <span class="c1">// for instructions that have one register operand</span>
   <span class="p">...</span>                 <span class="c1">// added to their opcode</span>
   <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">MRMDestReg</span><span class="o">:</span><span class="c1">// for instructions that use the Mod/RM byte</span>
   <span class="p">...</span>                 <span class="c1">// to specify a destination (register)</span>
   <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">MRMDestMem</span><span class="o">:</span><span class="c1">// for instructions that use the Mod/RM byte</span>
   <span class="p">...</span>                 <span class="c1">// to specify a destination (memory)</span>
   <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">MRMSrcReg</span><span class="o">:</span> <span class="c1">// for instructions that use the Mod/RM byte</span>
   <span class="p">...</span>                 <span class="c1">// to specify a source (register)</span>
   <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">MRMSrcMem</span><span class="o">:</span> <span class="c1">// for instructions that use the Mod/RM byte</span>
   <span class="p">...</span>                 <span class="c1">// to specify a source (memory)</span>
   <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">MRM0r</span><span class="o">:</span> <span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">MRM1r</span><span class="o">:</span>  <span class="c1">// for instructions that operate on</span>
<span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">MRM2r</span><span class="o">:</span> <span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">MRM3r</span><span class="o">:</span>  <span class="c1">// a REGISTER r/m operand and</span>
<span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">MRM4r</span><span class="o">:</span> <span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">MRM5r</span><span class="o">:</span>  <span class="c1">// use the Mod/RM byte and a field</span>
<span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">MRM6r</span><span class="o">:</span> <span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">MRM7r</span><span class="o">:</span>  <span class="c1">// to hold extended opcode data</span>
   <span class="p">...</span>
   <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">MRM0m</span><span class="o">:</span> <span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">MRM1m</span><span class="o">:</span>  <span class="c1">// for instructions that operate on</span>
<span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">MRM2m</span><span class="o">:</span> <span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">MRM3m</span><span class="o">:</span>  <span class="c1">// a MEMORY r/m operand and</span>
<span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">MRM4m</span><span class="o">:</span> <span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">MRM5m</span><span class="o">:</span>  <span class="c1">// use the Mod/RM byte and a field</span>
<span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">MRM6m</span><span class="o">:</span> <span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">MRM7m</span><span class="o">:</span>  <span class="c1">// to hold extended opcode data</span>
   <span class="p">...</span>
   <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">MRMInitReg</span><span class="o">:</span> <span class="c1">// for instructions whose source and</span>
   <span class="p">...</span>                  <span class="c1">// destination are the same register</span>
   <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The implementations of these case statements often first emit the opcode and
then get the operand(s).  Then depending upon the operand, helper methods may
be called to process the operand(s).  For example, in <tt class="docutils literal"><span class="pre">X86CodeEmitter.cpp</span></tt>,
for the <tt class="docutils literal"><span class="pre">X86II::AddRegFrm</span></tt> case, the first data emitted (by <tt class="docutils literal"><span class="pre">emitByte</span></tt>) is
the opcode added to the register operand.  Then an object representing the
machine operand, <tt class="docutils literal"><span class="pre">MO1</span></tt>, is extracted.  The helper methods such as
<tt class="docutils literal"><span class="pre">isImmediate</span></tt>, <tt class="docutils literal"><span class="pre">isGlobalAddress</span></tt>, <tt class="docutils literal"><span class="pre">isExternalSymbol</span></tt>,
<tt class="docutils literal"><span class="pre">isConstantPoolIndex</span></tt>, and <tt class="docutils literal"><span class="pre">isJumpTableIndex</span></tt> determine the operand type.
(<tt class="docutils literal"><span class="pre">X86CodeEmitter.cpp</span></tt> also has private methods such as <tt class="docutils literal"><span class="pre">emitConstant</span></tt>,
<tt class="docutils literal"><span class="pre">emitGlobalAddress</span></tt>, <tt class="docutils literal"><span class="pre">emitExternalSymbolAddress</span></tt>, <tt class="docutils literal"><span class="pre">emitConstPoolAddress</span></tt>,
and <tt class="docutils literal"><span class="pre">emitJumpTableAddress</span></tt> that emit the data into the output stream.)</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">case</span> <span class="n">X86II</span>:<span class="o">:</span><span class="n">AddRegFrm</span><span class="o">:</span>
  <span class="n">MCE</span><span class="p">.</span><span class="n">emitByte</span><span class="p">(</span><span class="n">BaseOpcode</span> <span class="o">+</span> <span class="n">getX86RegNum</span><span class="p">(</span><span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">CurOp</span><span class="o">++</span><span class="p">).</span><span class="n">getReg</span><span class="p">()));</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CurOp</span> <span class="o">!=</span> <span class="n">NumOps</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO1</span> <span class="o">=</span> <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">CurOp</span><span class="o">++</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="n">Size</span> <span class="o">=</span> <span class="n">X86InstrInfo</span><span class="o">::</span><span class="n">sizeOfImm</span><span class="p">(</span><span class="n">Desc</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MO1</span><span class="p">.</span><span class="n">isImmediate</span><span class="p">())</span>
      <span class="n">emitConstant</span><span class="p">(</span><span class="n">MO1</span><span class="p">.</span><span class="n">getImm</span><span class="p">(),</span> <span class="n">Size</span><span class="p">);</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="n">rt</span> <span class="o">=</span> <span class="n">Is64BitMode</span> <span class="o">?</span> <span class="n">X86</span><span class="o">::</span><span class="n">reloc_pcrel_word</span>
        <span class="o">:</span> <span class="p">(</span><span class="n">IsPIC</span> <span class="o">?</span> <span class="n">X86</span><span class="o">::</span><span class="n">reloc_picrel_word</span> <span class="o">:</span> <span class="n">X86</span><span class="o">::</span><span class="n">reloc_absolute_word</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">Opcode</span> <span class="o">==</span> <span class="n">X86</span><span class="o">::</span><span class="n">MOV64ri</span><span class="p">)</span>
        <span class="n">rt</span> <span class="o">=</span> <span class="n">X86</span><span class="o">::</span><span class="n">reloc_absolute_dword</span><span class="p">;</span>  <span class="c1">// FIXME: add X86II flag?</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">MO1</span><span class="p">.</span><span class="n">isGlobalAddress</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">NeedStub</span> <span class="o">=</span> <span class="n">isa</span><span class="o">&lt;</span><span class="n">Function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MO1</span><span class="p">.</span><span class="n">getGlobal</span><span class="p">());</span>
        <span class="kt">bool</span> <span class="n">isLazy</span> <span class="o">=</span> <span class="n">gvNeedsLazyPtr</span><span class="p">(</span><span class="n">MO1</span><span class="p">.</span><span class="n">getGlobal</span><span class="p">());</span>
        <span class="n">emitGlobalAddress</span><span class="p">(</span><span class="n">MO1</span><span class="p">.</span><span class="n">getGlobal</span><span class="p">(),</span> <span class="n">rt</span><span class="p">,</span> <span class="n">MO1</span><span class="p">.</span><span class="n">getOffset</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span>
                          <span class="n">NeedStub</span><span class="p">,</span> <span class="n">isLazy</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">MO1</span><span class="p">.</span><span class="n">isExternalSymbol</span><span class="p">())</span>
        <span class="n">emitExternalSymbolAddress</span><span class="p">(</span><span class="n">MO1</span><span class="p">.</span><span class="n">getSymbolName</span><span class="p">(),</span> <span class="n">rt</span><span class="p">);</span>
      <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">MO1</span><span class="p">.</span><span class="n">isConstantPoolIndex</span><span class="p">())</span>
        <span class="n">emitConstPoolAddress</span><span class="p">(</span><span class="n">MO1</span><span class="p">.</span><span class="n">getIndex</span><span class="p">(),</span> <span class="n">rt</span><span class="p">);</span>
      <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">MO1</span><span class="p">.</span><span class="n">isJumpTableIndex</span><span class="p">())</span>
        <span class="n">emitJumpTableAddress</span><span class="p">(</span><span class="n">MO1</span><span class="p">.</span><span class="n">getIndex</span><span class="p">(),</span> <span class="n">rt</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<p>In the previous example, <tt class="docutils literal"><span class="pre">XXXCodeEmitter.cpp</span></tt> uses the variable <tt class="docutils literal"><span class="pre">rt</span></tt>, which
is a <tt class="docutils literal"><span class="pre">RelocationType</span></tt> enum that may be used to relocate addresses (for
example, a global address with a PIC base offset).  The <tt class="docutils literal"><span class="pre">RelocationType</span></tt> enum
for that target is defined in the short target-specific <tt class="docutils literal"><span class="pre">XXXRelocations.h</span></tt>
file.  The <tt class="docutils literal"><span class="pre">RelocationType</span></tt> is used by the <tt class="docutils literal"><span class="pre">relocate</span></tt> method defined in
<tt class="docutils literal"><span class="pre">XXXJITInfo.cpp</span></tt> to rewrite addresses for referenced global symbols.</p>
<p>For example, <tt class="docutils literal"><span class="pre">X86Relocations.h</span></tt> specifies the following relocation types for
the X86 addresses.  In all four cases, the relocated value is added to the
value already in memory.  For <tt class="docutils literal"><span class="pre">reloc_pcrel_word</span></tt> and <tt class="docutils literal"><span class="pre">reloc_picrel_word</span></tt>,
there is an additional initial adjustment.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">enum</span> <span class="n">RelocationType</span> <span class="p">{</span>
  <span class="n">reloc_pcrel_word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>    <span class="c1">// add reloc value after adjusting for the PC loc</span>
  <span class="n">reloc_picrel_word</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>   <span class="c1">// add reloc value after adjusting for the PIC base</span>
  <span class="n">reloc_absolute_word</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="c1">// absolute relocation; no additional adjustment</span>
  <span class="n">reloc_absolute_dword</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1">// absolute relocation; no additional adjustment</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="target-jit-info">
<h3><a class="toc-backref" href="#id33">Target JIT Info</a><a class="headerlink" href="#target-jit-info" title="Permalink to this headline">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">XXXJITInfo.cpp</span></tt> implements the JIT interfaces for target-specific
code-generation activities, such as emitting machine code and stubs.  At
minimum, a target-specific version of <tt class="docutils literal"><span class="pre">XXXJITInfo</span></tt> implements the following:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">getLazyResolverFunction</span></tt> &#8212; Initializes the JIT, gives the target a
function that is used for compilation.</li>
<li><tt class="docutils literal"><span class="pre">emitFunctionStub</span></tt> &#8212; Returns a native function with a specified address
for a callback function.</li>
<li><tt class="docutils literal"><span class="pre">relocate</span></tt> &#8212; Changes the addresses of referenced globals, based on
relocation types.</li>
<li>Callback function that are wrappers to a function stub that is used when the
real target is not initially known.</li>
</ul>
<p><tt class="docutils literal"><span class="pre">getLazyResolverFunction</span></tt> is generally trivial to implement.  It makes the
incoming parameter as the global <tt class="docutils literal"><span class="pre">JITCompilerFunction</span></tt> and returns the
callback function that will be used a function wrapper.  For the Alpha target
(in <tt class="docutils literal"><span class="pre">AlphaJITInfo.cpp</span></tt>), the <tt class="docutils literal"><span class="pre">getLazyResolverFunction</span></tt> implementation is
simply:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">TargetJITInfo</span><span class="o">::</span><span class="n">LazyResolverFn</span> <span class="n">AlphaJITInfo</span><span class="o">::</span><span class="n">getLazyResolverFunction</span><span class="p">(</span>
                                            <span class="n">JITCompilerFn</span> <span class="n">F</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">JITCompilerFunction</span> <span class="o">=</span> <span class="n">F</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">AlphaCompilationCallback</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For the X86 target, the <tt class="docutils literal"><span class="pre">getLazyResolverFunction</span></tt> implementation is a little
more complicated, because it returns a different callback function for
processors with SSE instructions and XMM registers.</p>
<p>The callback function initially saves and later restores the callee register
values, incoming arguments, and frame and return address.  The callback
function needs low-level access to the registers or stack, so it is typically
implemented with assembler.</p>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="HowToUseInstrMappings.html" title="How To Use Instruction Mappings"
             >next</a> |</li>
        <li class="right" >
          <a href="Vectorizers.html" title="Auto-Vectorization in LLVM"
             >previous</a> |</li>
  <li><a href="http://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index-2.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2003-2014, LLVM Project.
      Last updated on 2014-04-24.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>

<!-- Mirrored from llvm.org/docs/WritingAnLLVMBackend.html by HTTrack Website Copier/3.x [XR&CO'2013], Sat, 26 Apr 2014 21:32:25 GMT -->
</html>